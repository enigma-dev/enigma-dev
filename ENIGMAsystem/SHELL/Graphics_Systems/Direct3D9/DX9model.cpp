/** Copyright (C) 2013 Robert B. Colton, Adriano Tumminelli
***
*** This file is a part of the ENIGMA Development Environment.
***
*** ENIGMA is free software: you can redistribute it and/or modify it under the
*** terms of the GNU General Public License as published by the Free Software
*** Foundation, version 3 of the license or any later version.
***
*** This application and its source code is distributed AS-IS, WITHOUT ANY
*** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
*** FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
*** details.
***
*** You should have received a copy of the GNU General Public License along
*** with this code. If not, see <http://www.gnu.org/licenses/>
**/

#include "Bridges/General/DX9Device.h"
#include "../General/GSd3d.h"
#include "DX9shapes.h"
#include "../General/GSprimitives.h"
#include "../General/GStextures.h"
#include "../General/GSmodel.h"
#include "Universal_System/var4.h"
#include "Universal_System/roomsystem.h"
#include <math.h>
#include <stdlib.h>
#include "DX9binding.h"

using namespace std;

#define __GETR(x) ((x & 0x0000FF))
#define __GETG(x) ((x & 0x00FF00)>>8)
#define __GETB(x) ((x & 0xFF0000)>>16)
#define __GETRf(x) fmod(__GETR(x),256)
#define __GETGf(x) fmod(x/256,256)
#define __GETBf(x) fmod(x/65536,256)*

#include <iostream>
#include <map>
#include <list>
#include "Universal_System/fileio.h"
#include "Universal_System/estring.h"

#include <vector>
using std::vector;

extern int ptypes_by_id[16];
namespace enigma {
  extern unsigned char currentcolor[4];
  
  //split a string and convert to float
  vector<float> float_split(const string& str, const char& ch) {
    string next;
    vector<float> result;

    for (string::const_iterator it = str.begin(); it != str.end(); it++)
	{
		if (*it == ch)
		{
			if (!next.empty())
			{
				result.push_back(atof(next.c_str()));
				next.clear();
			}
        } else {
            next += *it;
        }
    }
    if (!next.empty())
         result.push_back(atof(next.c_str()));
    return result;
  }

  //obj model parsing functions
  void string_parse( string *s )
  {
	size_t spaces = 0;
	bool trimmed = false;
	bool checknormal = false;
	for (unsigned int i = 0; i < s->size() ; i++)
	{ 
		//comment
		if ((*s)[i] == '#')
		{
			s->erase(i, s->length() - i);
			break;
		}
		else if((*s)[i] == ' ')
		{
			if (!trimmed)
			{
				s->erase(i,1);
				i--;
			}
			else
			{
				if (spaces >= 1)
				{
					s->erase(i,1);
					i--;
				}
				spaces++;
			}
		}
		else
		{
			if((*s)[i] == '/')
			{
				(*s)[i] = ' ';
				if(checknormal)
				{
					s->erase(i, 1);
					checknormal = false;
				}
				else
					checknormal = true;
			}
			else
				checknormal = false;
			spaces = 0;
			trimmed = true;
		}
	}
	//end trim
	if (s->size() > 0) {
		if ((*s)[s->size()-1] == ' ')
		{
			s->erase(s->size()-1, 1);
		}
	}
  }
}

/* Mesh clearing has a memory leak */
class Mesh
{
  public:
  unsigned currentPrimitive; //The type of the current primitive being added to the model

  vector<gs_scalar> vertices; // Temporary vertices container for the current primitive until they are batched
  vector<unsigned> indices; // Temporary indices that can optionally be supplied, otherwise they will get generated by the batcher.
  vector<gs_scalar> triangleVertices; // The vertices added to all triangle primitives batched into a single triangle list to be buffered to the GPU
  vector<unsigned> triangleIndices; // The triangle indices either concatenated by batching or supplied in the temporary container.
  vector<gs_scalar> lineVertices; // The vertices added to all line primitives batched into a single line list to be buffered to the GPU 
  vector<unsigned> lineIndices; // The line indices either concatenated by batching or supplied in the temporary container.
  vector<gs_scalar> pointVertices; // The vertices added to all point primitives batched into a single point list to be buffered to the GPU
  vector<unsigned> pointIndices; // The point indices either concatenated by batching or supplied in the temporary container.
  
  bool useColors; // If colors have been added to the model
  bool useTextures; // If texture coordinates have been added
  bool useNormals; // If normals have been added
  
  unsigned pointCount; // The number of indices in the point buffer
  unsigned triangleCount; // The number of indices in the triangle buffer
  unsigned triangleVertCount; // The number of vertices in the triangle buffer
  unsigned lineCount; // The number of indices in the line buffer
  unsigned lineVertCount; //The number of vertices in the line buffer
  
  LPDIRECT3DVERTEXBUFFER9 vertexbuffer;    // Interleaved vertex buffer object TRIANGLES|LINES|POINTS with triangles first since they are most likely to be used
  LPDIRECT3DINDEXBUFFER9 indexbuffer;    // Interleaved index buffer object TRIANGLES|LINES|POINTS with triangles first since they are most likely to be used
  IDirect3DVertexDeclaration9* vertex_declaration; // Pointer to our custom vertex declaration which we will use later for something actually flexible where FVF is not
  
  bool vbogenerated; // Whether or not the buffer objects have been generated
  bool vbobuffered; // Whether or not the buffer objects have been buffered
  
  void SetPrimitive(int pr) {
	vbobuffered = false;
	currentPrimitive = pr;
  }

  Mesh()
  {
  	vertexbuffer = NULL;    // the pointer to the vertex buffer
	indexbuffer = NULL;    // the pointer to the index buffer
	
    vbogenerated = false;
    vbobuffered = false;

	useColors = false;
    useTextures = false;
    useNormals = false;
	
	pointCount = 0;
	triangleCount = 0;
	triangleVertCount = 0;
	lineCount = 0;
	lineVertCount = 0;
	
    currentPrimitive = 0;
  }

  ~Mesh()
  {

  }
  
  void ClearData()
  {
    triangleVertices.clear();
	pointVertices.clear();
	lineVertices.clear();
	triangleIndices.clear();
	pointIndices.clear();
	lineIndices.clear();
  }

  void Clear()
  {
    ClearData();
	
	// Release the buffers and make sure we don't leave hanging pointers.
	vertexbuffer->Release();
	vertexbuffer = NULL;
	indexbuffer->Release();
	indexbuffer = NULL;
	
	vbogenerated = false;
	
	useColors = false;
    useTextures = false;
    useNormals = false;
	
	pointCount = 0;
	triangleCount = 0;
	triangleVertCount = 0;
	lineCount = 0;
	lineVertCount = 0;
  }
  
  void Begin(int pt)
  {
    vbobuffered = false;
    currentPrimitive = pt;
  }

  void AddVertex(gs_scalar x, gs_scalar y, gs_scalar z)
  {
    vertices.push_back(x); vertices.push_back(y); vertices.push_back(z);
  }
  
  void AddIndex(unsigned ind)
  {
    indices.push_back(ind);
  }

  void AddNormal(gs_scalar nx, gs_scalar ny, gs_scalar nz)
  {
    vertices.push_back(nx); vertices.push_back(ny); vertices.push_back(nz);
	useNormals = true;
  }

  void AddTexture(gs_scalar tx, gs_scalar ty)
  {
    vertices.push_back(tx); vertices.push_back(ty);
	useTextures = true;
  }

  // NOTE: The vertex format for this class should be written so that color is a single DWORD and not four floats.
  void AddColor(int col, double alpha)
  {               
	vertices.push_back((float)__GETR(col)/256); vertices.push_back((float)__GETG(col)/256); vertices.push_back((float)__GETB(col)/256); vertices.push_back(alpha);
	useColors = true;
  }
  
    void Translate(gs_scalar x, gs_scalar y, gs_scalar z)
  {
	unsigned int stride = 3 + (useNormals*3) + (useTextures*2)  + (useColors*4) ;
	unsigned int size = triangleVertices.size();
	for (unsigned int i = 0; i < size; i += stride)
	{
		triangleVertices[i] += x;
		triangleVertices[i+1] += y;
		triangleVertices[i+2] += z;
	}
  }
     
  void RotateUV(gs_scalar angle)
  {
	unsigned int stride = 3 + (useNormals*3) + (useTextures*2)  + (useColors*4) ;
	angle *= 3.14159/180.0;
	gs_scalar _cos = cos(angle);
	gs_scalar _sin = sin(angle);
	unsigned int size = triangleVertices.size();
	for (unsigned int i = 0; i < size; i += stride)
	{
		gs_scalar x = triangleVertices[i + 3 + 3*useNormals];
		gs_scalar y = triangleVertices[i + 4 + 3*useNormals];
		triangleVertices[i + 3 + 3*useNormals] = x*_cos - y*_sin;
		triangleVertices[i + 4 + 3*useNormals] = x*_sin - y*_cos;
	}
  }
  
  void ScaleUV(gs_scalar xscale, gs_scalar yscale)
  {
	unsigned int stride = 3 + useNormals*3 + useTextures*2 + useColors*4;

	for (vector<gs_scalar>::iterator i = triangleVertices.begin(); i != triangleVertices.end(); i += stride)
	{
		*(i + 3 + 3*useNormals) *= xscale;
		*(i + 4 + 3*useNormals) *= yscale;
	}
  }
  
   
  void RotateX(gs_scalar angle)
  {
	unsigned int stride = 3 + (useNormals*3) + (useTextures*2)  + (useColors*4) ;
	angle *= 3.14159/180.0;
	gs_scalar _cos = cos(angle);
	gs_scalar _sin = sin(angle);
	unsigned int size = triangleVertices.size();
	for (unsigned int i = 0; i < size; i += stride)
	{
		gs_scalar y = triangleVertices[i+1];
		gs_scalar z = triangleVertices[i+2];
		triangleVertices[i+1] = y*_cos - z*_sin;
		triangleVertices[i+2] = y*_sin - z*_cos;
	}
  }
  
  
  void RotateY(gs_scalar angle)
  {
	unsigned int stride = 3 + (useNormals*3) + (useTextures*2)  + (useColors*4) ;
	angle *= 3.14159/180.0;
	gs_scalar _cos = cos(angle);
	gs_scalar _sin = sin(angle);
	unsigned int size = triangleVertices.size();
	for (unsigned int i = 0; i < size; i += stride)
	{
		gs_scalar x = triangleVertices[i];
		gs_scalar z = triangleVertices[i+2];
		triangleVertices[i] = z*_sin - x*_cos;
		triangleVertices[i+2] = z*_cos - x*_sin;
	}
  }
  
  void RotateZ(gs_scalar angle)
  {
	unsigned int stride = 3 + (useNormals*3) + (useTextures*2)  + (useColors*4) ;
	angle *= 3.14159/180.0;
	gs_scalar _cos = cos(angle);
	gs_scalar _sin = sin(angle);
	unsigned int size = triangleVertices.size();
	for (unsigned int i = 0; i < size; i += stride)
	{
		gs_scalar x = triangleVertices[i];
		gs_scalar y = triangleVertices[i+1];
		triangleVertices[i] = x*_cos - y*_sin;
		triangleVertices[i+1] = x*_sin - y*_cos;
	}
  }
  
  void Scale(gs_scalar xscale, gs_scalar yscale, gs_scalar zscale)
  {
	unsigned int stride = 3 + useNormals*3 + useTextures*2 + useColors*4;

	for (vector<gs_scalar>::iterator i = triangleVertices.begin(); i != triangleVertices.end(); i += stride)
	{
		*(i+0) *= xscale;
		*(i+1) *= yscale;
		*(i+2) *= zscale;
	}
  }
  
  
  bool CalculateNormals(bool smooth, bool invert)
  {
	
	unsigned int stride = 3 + useNormals*3 + useTextures*2 + useColors*4;
	
	int oft = useNormals * 3;
	int ofc = oft + useTextures * 2 ;
	vector<gs_scalar> tempVertices;

	for (vector<gs_scalar>::const_iterator i = triangleVertices.begin(); i != triangleVertices.end(); i += stride*3)
	{
		gs_scalar x1 = *i;
		gs_scalar y1 = *(i+1);
		gs_scalar z1 = *(i+2);

		gs_scalar x2 = *(i +stride);
		gs_scalar y2 = *(i+1 +stride);
		gs_scalar z2 = *(i+2 +stride);
		
		gs_scalar x3 = *(i +stride*2);
		gs_scalar y3 = *(i+1 +stride*2);
		gs_scalar z3 = *(i+2 +stride*2);
		
		gs_scalar nX = (y2-y1)*(z3-z1)-(y3-y1)*(z2-z1);
		gs_scalar nY = (z2-z1)*(x3-x1)-(z3-z1)*(x2-x1);
		gs_scalar nZ = (x2-x1)*(y3-y1)-(x3-x1)*(y2-y1);
		gs_scalar  m = sqrt(nX*nX + nY*nY + nZ*nZ);
		nX /= m;
		nY /= m;
		nZ /= m;
		
		for(int n = 0; n < 3; n++)
		{
			int v = n*stride;
			//add position
			tempVertices.push_back(*(i+0 + v));
			tempVertices.push_back(*(i+1 + v));
			tempVertices.push_back(*(i+2 + v));
			//add normals
			if (invert) {
				tempVertices.push_back(nX * -1);
				tempVertices.push_back(nY * -1);
				tempVertices.push_back(nZ * -1);
			} else {
				tempVertices.push_back(nX);
				tempVertices.push_back(nY);
				tempVertices.push_back(nZ);
			}
			//add texture
			if(useTextures){
				tempVertices.push_back(*(i+3+oft + v));
				tempVertices.push_back(*(i+4+oft + v));
			}
			//add color
			if(useColors){
				tempVertices.push_back(*(i+5+ofc + v));
				tempVertices.push_back(*(i+6+ofc + v));
				tempVertices.push_back(*(i+7+ofc + v));
				tempVertices.push_back(*(i+8+ofc + v));
			}
		}
	}
	triangleVertices = tempVertices;
	useNormals = true;
	if(smooth) SmoothNormals();
	return true;
  }
  
  void SmoothNormals()
  {
	unsigned int stride = 3 + useNormals*3 + useTextures*2 + useColors*4;
	
	vector<vector<unsigned int> > groupList;
	unsigned int n = 0;
	//group all vertices
	for (vector<gs_scalar>::const_iterator i = triangleVertices.begin(); i != triangleVertices.end(); i += stride)
	{
		gs_scalar x1 = *(i+0);
		gs_scalar y1 = *(i+1);
		gs_scalar z1 = *(i+2);
		
		bool added = false;
		//check each group 
		if (groupList.size() > 0)
		for (vector< vector<unsigned int> >::iterator ig = groupList.begin(); ig != groupList.end(); ++ig)
		{
			
			//compute first element and add it if has the same position
			unsigned int index = (*ig)[0];
			gs_scalar x2 = triangleVertices[index*stride + 0];
			gs_scalar y2 = triangleVertices[index*stride + 1];
			gs_scalar z2 = triangleVertices[index*stride + 2]; 
			if( x1 == x2 && y1 == y2 && z1 == z2)
			{
				added = true;
				(*ig).push_back(n);
				break;
			}
			 
		}
		if (!added)
		{
			vector<unsigned int> vec = vector<unsigned int>();
			vec.push_back(n);
			groupList.push_back(vec);
		}
		 
		n++;
	}
	
	//add average values
	for (vector< vector<unsigned int> >::iterator ig = groupList.begin(); ig != groupList.end(); ++ig)
	{
		gs_scalar count = 0;
		gs_scalar anx = 0, any = 0, anz = 0;
		for (vector<unsigned int>::iterator i = (*ig).begin(); i != (*ig).end(); ++i)
		{
			anx += triangleVertices[(*i)*stride+3];
			any += triangleVertices[(*i)*stride+4];
			anz += triangleVertices[(*i)*stride+5];
			
			count++;
		}
		anx /= count;
		any /= count;
		anz /= count;
		
		for (vector<unsigned int>::iterator i = (*ig).begin(); i != (*ig).end(); ++i)
		{
			triangleVertices[(*i)*stride+3] = anx;
			triangleVertices[(*i)*stride+4] = any;
			triangleVertices[(*i)*stride+5] = anz;
		}
	}
  }

  void End()
  {
	//NOTE: This batching only checks for degenerate primitives on triangle strips and fans since the GPU does not render triangles where the two
	//vertices are exactly the same, triangle lists could also check for degenerates, it is unknown whether the GPU will render a degenerative 
	//in a line strip primitive.
	
	unsigned stride = 3;
    if (useNormals) stride += 3;
	if (useTextures) stride += 2;
    if (useColors) stride += 4;
	
	// Primitive has ended so now we need to batch the vertices that were given into single lists, eg. line list, triangle list, point list
	// Indices are optionally supplied, model functions can also be added for the end user to supply the indexing themselves for each primitive
	// but the batching system does not care either way if they are not supplied it will automatically generate them.
	switch (currentPrimitive) {
		case enigma_user::pr_pointlist:
			pointVertices.insert(pointVertices.end(), vertices.begin(), vertices.end());
			if (indices.size() > 0) {
				for (std::vector<unsigned>::iterator it = indices.begin(); it != indices.end(); ++it) { *it += pointCount; }
				pointIndices.insert(pointIndices.end(), indices.begin(), indices.end());
			} else {
				for (unsigned i = 0; i < vertices.size() / stride; i++) {
					pointIndices.push_back(pointCount + i);
				}
			}
			pointCount += vertices.size() / stride;
			break;
		case enigma_user::pr_linestrip:
			lineVertices.insert(lineVertices.end(), vertices.begin(), vertices.end());
			if (indices.size() > 0) {
				for (std::vector<unsigned>::iterator it = indices.begin(); it != indices.end(); ++it) { *it += lineCount; }
				for (unsigned i = 0; i < indices.size() - 2; i++) {
					lineIndices.push_back(indices[i]);
					lineIndices.push_back(indices[i + 1]);
				}
			} else {
				for (unsigned i = 0; i < vertices.size() / stride - 1; i++) {
					lineIndices.push_back(lineCount + i);
					lineIndices.push_back(lineCount + i + 1);
				}
			}
			lineCount += vertices.size() / stride;
			break;
		case enigma_user::pr_linelist:
			lineVertices.insert(lineVertices.end(), vertices.begin(), vertices.end());
			if (indices.size() > 0) {
				for (std::vector<unsigned>::iterator it = indices.begin(); it != indices.end(); ++it) { *it += lineCount; }
				lineIndices.insert(lineIndices.end(), indices.begin(), indices.end());
			} else {
				for (unsigned i = 0; i < vertices.size() / stride; i++) {
					lineIndices.push_back(lineCount + i);
				}
			}
			lineCount += vertices.size() / stride;
			break;
		case enigma_user::pr_trianglestrip:
			triangleVertices.insert(triangleVertices.end(), vertices.begin(), vertices.end());
			if (indices.size() > 0) {
				for (std::vector<unsigned>::iterator it = indices.begin(); it != indices.end(); ++it) { *it += triangleCount; }
				for (unsigned i = 0; i < indices.size() - 2; i++) {
					// check for and continue if indexed triangle is degenerate, because the GPU won't render it anyway
					if (indices[i] == indices[i + 1] || indices[i] == indices[i + 2]  || indices[i + 1] == indices[i + 2] ) { continue; }
					triangleIndices.push_back(indices[i]);
					triangleIndices.push_back(indices[i+1]);
					triangleIndices.push_back(indices[i+2]);
				}
			} else {
				for (unsigned i = 0; i < vertices.size() / stride - 2; i++) {
					if (i % 2) {
						triangleIndices.push_back(triangleCount + i + 2);
						triangleIndices.push_back(triangleCount + i + 1);
						triangleIndices.push_back(triangleCount + i);
					} else {
						triangleIndices.push_back(triangleCount + i);
						triangleIndices.push_back(triangleCount + i + 1);
						triangleIndices.push_back(triangleCount + i + 2);
					}
				}
			}
			triangleCount += vertices.size() / stride;
			break;
		case enigma_user::pr_trianglelist:
			triangleVertices.insert(triangleVertices.end(), vertices.begin(), vertices.end());
			if (indices.size() > 0) {
				for (std::vector<unsigned>::iterator it = indices.begin(); it != indices.end(); ++it) { *it += triangleCount; }
				triangleIndices.insert(triangleIndices.end(), indices.begin(), indices.end());
			} else {
				for (unsigned i = 0; i < vertices.size() / stride; i++) {
					triangleIndices.push_back(triangleCount + i);
				}
			}
			triangleCount += vertices.size() / stride;
			break;
		case enigma_user::pr_trianglefan:
			triangleVertices.insert(triangleVertices.end(), vertices.begin(), vertices.end());
			if (indices.size() > 0) {
				for (std::vector<unsigned>::iterator it = indices.begin(); it != indices.end(); ++it) { *it += triangleCount; }
				for (unsigned i = 1; i < indices.size() - 1; i++) {
					// check for and continue if indexed triangle is degenerate, because the GPU won't render it anyway
					if (indices[0] == indices[i] || indices[0] == indices[i + 1]  || indices[i] == indices[i + 1] ) { continue; }
					triangleIndices.push_back(indices[0]);
					triangleIndices.push_back(indices[i]);
					triangleIndices.push_back(indices[i + 1]);
				}
			} else {
				for (unsigned i = 1; i < vertices.size() / stride - 1; i++) {
					triangleIndices.push_back(triangleCount);
					triangleIndices.push_back(triangleCount + i);
					triangleIndices.push_back(triangleCount + i + 1);
				}
			}
			triangleCount += vertices.size() / stride;
			break;
	}

	// Clean up the temporary vertex and index containers now that they have been batched efficiently
	vertices.clear();
	indices.clear();
  }

  void BufferGenerate(bool subdata)
  {
	vector<gs_scalar> vdata;
	vector<unsigned> idata;
	
	unsigned interleave = 0;
		
	if (triangleCount > 0) {
		vdata.insert(vdata.begin(), triangleVertices.begin(), triangleVertices.end());
		idata.insert(idata.begin(), triangleIndices.begin(), triangleIndices.end());
		triangleVertCount = triangleCount;
		triangleCount = triangleIndices.size();
	}
	
	if (lineCount > 0) {
		vdata.insert(vdata.begin(), lineVertices.begin(), lineVertices.end());
		interleave += triangleVertices.size();
		for (std::vector<unsigned>::iterator it = lineIndices.begin(); it != lineIndices.end(); ++it) { *it += interleave; }
		idata.insert(idata.begin(), lineIndices.begin(), lineIndices.end());
		lineVertCount = lineCount;
		lineCount = lineIndices.size();
	}
	
	if (pointCount > 0) {
		vdata.insert(vdata.begin(), pointVertices.begin(), pointVertices.end());
		interleave += lineVertices.size();
		for (std::vector<unsigned>::iterator it = lineIndices.begin(); it != lineIndices.end(); ++it) { *it += interleave; }
		idata.insert(idata.begin(), pointIndices.begin(), pointIndices.end());
		pointCount = pointIndices.size();
	}
	
	D3DVERTEXELEMENT9 POSITIONELEMENT =
	{ 0,  0, D3DDECLTYPE_FLOAT3,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0 };
	unsigned stride = 3;

	D3DVERTEXELEMENT9 NORMALELEMENT =
	{ 0, static_cast< WORD >(stride * sizeof(gs_scalar)), D3DDECLTYPE_FLOAT3,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_NORMAL,   0 };
	if (useNormals) stride += 3;

	D3DVERTEXELEMENT9 TEXTUREELEMENT =
	{ 0, static_cast< WORD >(stride * sizeof(gs_scalar)), D3DDECLTYPE_FLOAT2,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0 };
	if (useTextures) stride += 2;

	D3DVERTEXELEMENT9 COLORELEMENT =
	{ 0, static_cast< WORD >(stride * sizeof(gs_scalar)), D3DDECLTYPE_FLOAT4, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR,    0  };
	if (useColors) stride += 4;

	int elements = 1 + useNormals + useTextures + useColors + 1;
	D3DVERTEXELEMENT9 customvertex[elements];
	customvertex[0] = POSITIONELEMENT;
	int i = 1;
	if (useNormals) { customvertex[i] = NORMALELEMENT; i += 1; }
	if (useTextures) { customvertex[i] = TEXTUREELEMENT; i += 1; }
	if (useColors) { customvertex[i] = COLORELEMENT; i += 1; }
	// declared const for C++0x compatibility
	const D3DVERTEXELEMENT9 strideelement = D3DDECL_END();
	customvertex[i] = strideelement;
	
	d3ddev->CreateVertexDeclaration (customvertex, &vertex_declaration);
	
	// create a vertex buffer interface
	d3ddev->CreateVertexBuffer(vdata.size() * sizeof( gs_scalar ),
		D3DUSAGE_WRITEONLY,
		0,
		D3DPOOL_MANAGED,
		&vertexbuffer,
		NULL);
					
	// create a index buffer interface
	d3ddev->CreateIndexBuffer(idata.size() * sizeof(unsigned),
		D3DUSAGE_WRITEONLY,
        D3DFMT_INDEX32,
        D3DPOOL_MANAGED,
        &indexbuffer,
        NULL);
		
	
	// Send the data to the GPU
	if (subdata) {
		//NOTE: Buffering subdata might not be any different in DX than just buffering it
	} else {
		VOID* pVoid;    // a void pointer
		// lock vertex buffer and load the vertices into it
		vertexbuffer->Lock(0, 0, (VOID**)&pVoid, 0);
		memcpy(pVoid, &vdata[0], vdata.size() * sizeof(gs_scalar));
		
		vertexbuffer->Unlock();
	  
		// lock index buffer and load the indices into it
		indexbuffer->Lock(0, 0, (void**)&pVoid, 0);
		memcpy(pVoid, &idata[0], idata.size() * sizeof(unsigned));
		indexbuffer->Unlock();
	}

	// Clean up temporary interleaved data
	vdata.clear();
	idata.clear();
    // Clean up the data from RAM it is now safe on VRAM
    ClearData();
  }

  void Draw()
  {
    if (!vbogenerated) {
      vbogenerated = true;
	  vbobuffered = true;
      BufferGenerate(false);
    } else if (!vbobuffered) {
	  vbobuffered = true;
	  BufferGenerate(true);
	}
  
	unsigned stride = 3;
    if (useNormals) stride += 3;
	if (useTextures) stride += 2;
    if (useColors) stride += 4;
	

	
	d3ddev->SetVertexDeclaration(vertex_declaration);
	// select the vertex buffer to display
	d3ddev->SetStreamSource(0, vertexbuffer, 0, stride * sizeof(gs_scalar));
	d3ddev->SetIndices(indexbuffer);
	
		//dsprite->Flush();
	//dsprite->End();
	
	// Draw the batched triangle list
	if (triangleCount > 0) { 
		d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 
			triangleVertCount, 0, triangleCount / 3);
	}
	
	// Draw the batched line list
	if (lineCount > 0) {
		d3ddev->DrawIndexedPrimitive(D3DPT_LINELIST, triangleVertCount, 0, 
			lineVertCount, triangleCount, lineCount / 2);
	}
	
	// Draw the batched point list
	if (pointCount > 0) {
		d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, triangleVertCount + lineVertCount, 0, 
			pointCount, triangleCount + lineCount, pointCount);
	}

	//dsprite->Begin(D3DXSPRITE_ALPHABLEND | D3DXSPRITE_DO_NOT_ADDREF_TEXTURE);
  }
};

vector<Mesh*> meshes;

namespace enigma_user
{

unsigned d3d_model_create()
{
  unsigned id = meshes.size();
  meshes.push_back(new Mesh());
  return id;
}

void d3d_model_destroy(int id)
{
  meshes[id]->Clear();
  delete meshes[id];
}

bool d3d_model_exists(int id)
{
  return (id >= 0 && (unsigned)id < meshes.size());
}

void d3d_model_clear(int id)
{
  meshes[id]->Clear();
}

void d3d_model_save(int id, string fname)
{
  //TODO: Write save code for meshes, will need to get the vertex data back from the GPU if buffered
}

bool d3d_model_load(int id, string fname)
{
  //TODO: this needs to be rewritten properly not using the file_text functions
  using namespace enigma_user;
  
  int file = file_text_open_read(fname);
  
  if (file == -1) {
	return false;
  }
  
  string fileExt = fname.substr(fname.find_last_of(".") + 1) ;
  if (fileExt == "obj")
  {
	vector< float > vertices;
	vector< float > uvs;
	vector< float > normals;
	
	int faceCount = 0;
	bool hasTexture = false;
	bool hasNormals = false;
	meshes[id]->Begin(pr_trianglelist);
	
	while (!file_text_eof(file))
	{
		string line = file_text_read_string(file);
		file_text_readln(file);
		enigma::string_parse(&line); 
		if (line.length() > 0)
		{
			if(line[0] == 'v')
			{
				vector<float> floats = enigma::float_split(line, ' ');
				floats.erase( floats.begin());
					
				int n = 0;
				switch(line[1])
				{
				case ' ':
					n = 0;
					for( vector<float>::const_iterator i = floats.begin(); i != floats.end(); ++i)
					{
						if(n < 3) vertices.push_back(*i);
						n++;
					}
					break;
				case 't':
					n = 0;
					for( vector<float>::const_iterator i = floats.begin(); i != floats.end(); ++i)
					{
						if(n < 2) uvs.push_back(*i);
						n++;
					}
					hasTexture = true;
					break;
				case 'n':
					n = 0;
					for( vector<float>::const_iterator i = floats.begin(); i != floats.end(); ++i)
					{
						if(n < 3) normals.push_back(*i);
						n++;
					}
					hasNormals = true;
					break;
				default:
					break;
				}
			}
			else if(line[0] == 'f')
			{
				faceCount++; 
				vector<float> f = enigma::float_split(line, ' ');
				f.erase( f.begin());
				int faceVertices = f.size() / (1 + hasTexture + hasNormals);
				int of = 1 + hasTexture + hasNormals;
				
				meshes[id]->AddVertex(vertices[(f[0]-1)*3],  vertices[(f[0]-1)*3 +1], vertices[(f[0]-1)*3 +2]);
				if(hasNormals) meshes[id]->AddNormal(normals[(f[2]-1)*3], normals[(f[2]-1)*3 +1], normals[(f[2]-1)*3 +2]);
				if(hasTexture) meshes[id]->AddTexture(uvs[(f[1]-1)*2], 1 - uvs[(f[1]-1)*2 +1]);
				
				meshes[id]->AddVertex(vertices[(f[1*of]-1)*3],  vertices[(f[1*of]-1)*3 +1] , vertices[(f[1*of]-1)*3 +2]);
				if(hasNormals) meshes[id]->AddNormal(normals[(f[1*of + 2]-1)*3], normals[(f[1*of  + 2]-1)*3 +1], normals[(f[1*of  + 2]-1)*3 +2]);
				if(hasTexture) meshes[id]->AddTexture(uvs[(f[1*of + 1]-1)*2], 1 - uvs[(f[1*of + 1]-1)*2 +1]);
				
				meshes[id]->AddVertex(vertices[(f[2*of]-1)*3],  vertices[(f[2*of]-1)*3 +1] , vertices[(f[2*of]-1)*3 +2]);
				if(hasNormals) meshes[id]->AddNormal(normals[(f[2*of + 2]-1)*3], normals[(f[2*of  + 2]-1)*3 +1], normals[(f[2*of  + 2]-1)*3 +2]);
				if(hasTexture) meshes[id]->AddTexture(uvs[(f[2*of + 1]-1)*2], 1 - uvs[(f[2*of + 1]-1)*2 +1]);
				
				//is a quad
				if(faceVertices == 4)
				{
					meshes[id]->AddVertex(vertices[(f[2*of]-1)*3],  vertices[(f[2*of]-1)*3 +1] , vertices[(f[2*of]-1)*3 +2]);
					if(hasNormals) meshes[id]->AddNormal(normals[(f[2*of + 2]-1)*3], normals[(f[2*of  + 2]-1)*3 +1], normals[(f[2*of  + 2]-1)*3 +2]);
					if(hasTexture) meshes[id]->AddTexture(uvs[(f[2*of + 1]-1)*2], 1 - uvs[(f[2*of + 1]-1)*2 +1]);
					
					meshes[id]->AddVertex( vertices[(f[3*of]-1)*3],  vertices[(f[3*of]-1)*3 +1] , vertices[(f[3*of]-1)*3 +2]);
					if(hasNormals) meshes[id]->AddNormal(normals[(f[3*of + 2]-1)*3], normals[(f[3*of  + 2]-1)*3 +1], normals[(f[3*of  + 2]-1)*3 +2]);
					if(hasTexture) meshes[id]->AddTexture(uvs[(f[3*of + 1]-1)*2], 1 - uvs[(f[3*of + 1]-1)*2 +1]);
					
					meshes[id]->AddVertex(vertices[(f[0]-1)*3],  vertices[(f[0]-1)*3 +1], vertices[(f[0]-1)*3 +2]);
					if(hasNormals) meshes[id]->AddNormal(normals[(f[2]-1)*3], normals[(f[2]-1)*3 +1], normals[(f[2]-1)*3 +2]);
					if(hasTexture) meshes[id]->AddTexture(uvs[(f[0 + 1]-1)*2], 1 - uvs[(f[0 + 1]-1)*2 +1]);
				}
				
			}	
		}
	}
	meshes[id]->End();  
	
  }
  else
  {
	  int something = file_text_read_real(file);
	  if (something != 100) {
		return false;
	  }
	  file_text_readln(file);
	  file_text_read_real(file);  //don't see the use in this value, it doesn't equal the number of calls left exactly
	  file_text_readln(file);
	  int kind;
	  float v[3], n[3], t[2];
	  double col, alpha;
	  while (!file_text_eof(file))
	  {
		switch (int(file_text_read_real(file)))
		{
		  case  0:
			kind = file_text_read_real(file);
			d3d_model_primitive_begin(id, kind);
			break;
		  case  1:
			d3d_model_primitive_end(id);
			break;
		  case  2:
			v[0] = file_text_read_real(file); v[1] = file_text_read_real(file); v[2] = file_text_read_real(file);
			d3d_model_vertex(id, v[0],v[1],v[2]);
			break;
		  case  3:
			v[0] = file_text_read_real(file); v[1] = file_text_read_real(file); v[2] = file_text_read_real(file);
			col = file_text_read_real(file); alpha = file_text_read_real(file);
			d3d_model_vertex_color(id, v[0],v[1],v[2],col,alpha);
			break;
		  case  4:
			v[0] = file_text_read_real(file); v[1] = file_text_read_real(file); v[2] = file_text_read_real(file);
			t[0] = file_text_read_real(file); t[1] = file_text_read_real(file);
			d3d_model_vertex_texture(id, v[0],v[1],v[2],t[0],t[1]);
			break;
		  case  5:
			v[0] = file_text_read_real(file); v[1] = file_text_read_real(file); v[2] = file_text_read_real(file);
			t[0] = file_text_read_real(file); t[1] = file_text_read_real(file);
			col = file_text_read_real(file); alpha = file_text_read_real(file);
			d3d_model_vertex_texture_color(id, v[0],v[1],v[2],t[0],t[1],col,alpha);
			break;
		  case  6:
			v[0] = file_text_read_real(file); v[1] = file_text_read_real(file); v[2] = file_text_read_real(file);
			n[0] = file_text_read_real(file); n[1] = file_text_read_real(file); n[2] = file_text_read_real(file);
			d3d_model_vertex_normal(id, v[0],v[1],v[2],n[0],n[1],n[2]);
			break;
		  case  7:
			v[0] = file_text_read_real(file); v[1] = file_text_read_real(file); v[2] = file_text_read_real(file);
			n[0] = file_text_read_real(file); n[1] = file_text_read_real(file); n[2] = file_text_read_real(file);
			col = file_text_read_real(file); alpha = file_text_read_real(file);
			d3d_model_vertex_normal_color(id, v[0],v[1],v[2],n[0],n[1],n[2],col,alpha);
			break;
		  case  8:
			v[0] = file_text_read_real(file); v[1] = file_text_read_real(file); v[2] = file_text_read_real(file);
			n[0] = file_text_read_real(file); n[1] = file_text_read_real(file); n[2] = file_text_read_real(file);
			t[0] = file_text_read_real(file); t[1] = file_text_read_real(file);
			d3d_model_vertex_normal_texture(id, v[0],v[1],v[2],n[0],n[1],n[2],t[0],t[1]);
			break;
		  case  9:
			v[0] = file_text_read_real(file); v[1] = file_text_read_real(file); v[2] = file_text_read_real(file);
			n[0] = file_text_read_real(file); n[1] = file_text_read_real(file); n[2] = file_text_read_real(file);
			t[0] = file_text_read_real(file); t[1] = file_text_read_real(file);
			col = file_text_read_real(file); alpha = file_text_read_real(file);
			d3d_model_vertex_normal_texture_color(id, v[0],v[1],v[2],n[0],n[1],n[2],t[0],t[1],col,alpha);
			break;
		  case  10:
			d3d_model_block(id, file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file), true);
			break;
		  case  11:
			d3d_model_cylinder(id, file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file));
			break;
		  case  12:
			d3d_model_cone(id, file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file));
			break;
		  case  13:
			d3d_model_ellipsoid(id, file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file));
			break;
		  case  14:
			d3d_model_wall(id, file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file));
			break;
		  case  15:
			d3d_model_floor(id, file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file),file_text_read_real(file));
			break;
		}
		file_text_readln(file);
	  }
  }
  file_text_close(file);
  return true;
}

void d3d_model_translate(int id, gs_scalar x, gs_scalar y, gs_scalar z)
{
  meshes[id]->Translate(x, y, z);
}

void d3d_model_scale(int id, gs_scalar xscale, gs_scalar yscale, gs_scalar zscale)
{
  meshes[id]->Scale(xscale, yscale, zscale);
}

void d3d_model_rotate_x(int id, gs_scalar angle)
{
  meshes[id]->RotateX(angle);
}

void d3d_model_rotate_y(int id, gs_scalar angle)
{
  meshes[id]->RotateY(angle);
}

void d3d_model_rotate_z(int id, gs_scalar angle)
{
  meshes[id]->RotateZ(angle);
}

bool d3d_model_calculate_normals(int id, bool smooth, bool invert)
{
  return meshes[id]->CalculateNormals(smooth, invert);
}

void d3d_model_draw(int id) // overload for no additional texture or transformation call's
{
    meshes[id]->Draw();
}

void d3d_model_draw(int id, gs_scalar x, gs_scalar y, gs_scalar z) // overload for no additional texture call's
{
    d3d_transform_add_translation(x, y, z);
    meshes[id]->Draw();
    d3d_transform_add_translation(-x, -y, -z);
}

void d3d_model_draw(int id, int texId)
{
    texture_use(texId);
    meshes[id]->Draw();
}

void d3d_model_draw(int id, gs_scalar x, gs_scalar y, gs_scalar z, int texId)
{
    texture_use(texId);
    d3d_model_draw(id, x, y, z);
}

void d3d_model_primitive_begin(int id, int kind)
{
  meshes[id]->Begin(kind);
}

void d3d_model_primitive_end(int id)
{
  meshes[id]->End();
}

void d3d_model_vertex(int id, gs_scalar x, gs_scalar y, gs_scalar z)
{
  meshes[id]->AddVertex(x, y, z);
}

void d3d_model_index(int id, unsigned ind) {
  meshes[id]->AddIndex(ind);
}

void d3d_model_vertex_color(int id, gs_scalar x, gs_scalar y, gs_scalar z, int col, double alpha)
{
  meshes[id]->AddVertex(x, y, z);
  meshes[id]->AddColor(col, alpha);
}

void d3d_model_vertex_texture(int id, gs_scalar x, gs_scalar y, gs_scalar z, gs_scalar tx, gs_scalar ty)
{
  meshes[id]->AddVertex(x, y, z);
  meshes[id]->AddTexture(tx, ty);
}

void d3d_model_vertex_texture_color(int id, gs_scalar x, gs_scalar y, gs_scalar z, gs_scalar tx, gs_scalar ty, int col, double alpha)
{
  meshes[id]->AddVertex(x, y, z);
  meshes[id]->AddTexture(tx, ty);
  meshes[id]->AddColor(col, alpha);
}

void d3d_model_vertex_normal(int id, gs_scalar x, gs_scalar y, gs_scalar z, gs_scalar nx, gs_scalar ny, gs_scalar nz)
{
  meshes[id]->AddVertex(x, y, z);
  meshes[id]->AddNormal(nx, ny, nz);
}

void d3d_model_vertex_normal_color(int id, gs_scalar x, gs_scalar y, gs_scalar z, gs_scalar nx, gs_scalar ny, gs_scalar nz, int col, double alpha)
{
  meshes[id]->AddVertex(x, y, z);
  meshes[id]->AddNormal(nx, ny, nz);
  meshes[id]->AddColor(col, alpha);
}

void d3d_model_vertex_normal_texture(int id, gs_scalar x, gs_scalar y, gs_scalar z, gs_scalar nx, gs_scalar ny, gs_scalar nz, gs_scalar tx, gs_scalar ty)
{
  meshes[id]->AddVertex(x, y, z);
  meshes[id]->AddNormal(nx, ny, nz);
  meshes[id]->AddTexture(tx, ty);
}

void d3d_model_vertex_normal_texture_color(int id, gs_scalar x, gs_scalar y, gs_scalar z, gs_scalar nx, gs_scalar ny, gs_scalar nz, gs_scalar tx, gs_scalar ty, int col, double alpha)
{
  meshes[id]->AddVertex(x, y, z);
  meshes[id]->AddNormal(nx, ny, nz);
  meshes[id]->AddTexture(tx, ty);
  meshes[id]->AddColor(col, alpha);
}

void d3d_model_block(int id, gs_scalar x1, gs_scalar y1, gs_scalar z1, gs_scalar x2, gs_scalar y2, gs_scalar z2, gs_scalar hrep, gs_scalar vrep, bool closed)
{
	//NOTE: This is the fastest way to batch cubes with uninterpolated normals thanks to my model batching, still slower than a triangle strip with interpolated normals
	//however.
	// Negative X
	d3d_model_primitive_begin( id, pr_trianglefan );
	d3d_model_vertex_normal_texture( id, x1,y1,z1, -1,0,0, 0,1 );
	d3d_model_vertex_normal_texture( id, x1,y1,z2, -1,0,0, 0,0 );
	d3d_model_vertex_normal_texture( id, x1,y2,z2, -1,0,0, 1,0 );
	d3d_model_vertex_normal_texture( id, x1,y2,z1, -1,0,0, 1,1 );
	d3d_model_primitive_end(id);

	// Positive X
	d3d_model_primitive_begin( id, pr_trianglefan );
	d3d_model_vertex_normal_texture( id, x2,y1,z1, 1,0,0, 1,1 );
	d3d_model_vertex_normal_texture( id, x2,y2,z1, 1,0,0, 0,1 );
	d3d_model_vertex_normal_texture( id, x2,y2,z2, 1,0,0, 0,0 );
	d3d_model_vertex_normal_texture( id, x2,y1,z2, 1,0,0, 1,0 );
	d3d_model_primitive_end( id );
	
	// Negative Y
	d3d_model_primitive_begin( id, pr_trianglefan );
	d3d_model_vertex_normal_texture( id, x1,y1,z1, 0,-1,0, 0,1 );
	d3d_model_vertex_normal_texture( id, x2,y1,z1, 0,-1,0, 1,1 );
	d3d_model_vertex_normal_texture( id, x2,y1,z2, 0,-1,0, 1,0 );
	d3d_model_vertex_normal_texture( id, x1,y1,z2, 0,-1,0, 0,0 );
	d3d_model_primitive_end( id );

	// Positive Y
	d3d_model_primitive_begin( id, pr_trianglefan );
	d3d_model_vertex_normal_texture( id, x1,y2,z1, 0,1,0, 1,1 );
	d3d_model_vertex_normal_texture( id, x1,y2,z2, 0,1,0, 1,0 );
	d3d_model_vertex_normal_texture( id, x2,y2,z2, 0,1,0, 0,0 );
	d3d_model_vertex_normal_texture( id, x2,y2,z1, 0,1,0, 0,1 );
	d3d_model_primitive_end( id );
	
	if (closed) {
		// Negative Z
		d3d_model_primitive_begin( id, pr_trianglefan );
		d3d_model_vertex_normal_texture( id, x1,y1,z1, 0,0,-1, 0,0 );
		d3d_model_vertex_normal_texture( id, x1,y2,z1, 0,0,-1, 0,1 );
		d3d_model_vertex_normal_texture( id, x2,y2,z1, 0,0,-1, 1,1 );
		d3d_model_vertex_normal_texture( id, x2,y1,z1, 0,0,-1, 1,0 );
		d3d_model_primitive_end( id );

		// Positive Z
		d3d_model_primitive_begin( id, pr_trianglefan );
		d3d_model_vertex_normal_texture( id, x1,y1,z2, 0,0,1, 0,0 );
		d3d_model_vertex_normal_texture( id, x2,y1,z2, 0,0,1, 1,0 );
		d3d_model_vertex_normal_texture( id, x2,y2,z2, 0,0,1, 1,1 );
		d3d_model_vertex_normal_texture( id, x1,y2,z2, 0,0,1, 0,1 );
		d3d_model_primitive_end( id );
	}
}

void d3d_model_cylinder(int id, gs_scalar x1, gs_scalar y1, gs_scalar z1, gs_scalar x2, gs_scalar y2, gs_scalar z2, gs_scalar hrep, gs_scalar vrep, bool closed, int steps)
{
        gs_scalar v[100][3];
        gs_scalar t[100][3];
        steps = min(max(steps, 3), 48); // i think 48 should be circle_presicion
        const double cx = (x1+x2)/2, cy = (y1+y2)/2, rx = (x2-x1)/2, ry = (y2-y1)/2, invstep = (1.0/steps)*hrep, pr = 2*M_PI/steps;
        double a, px, py, tp;
        int k;
        a = 0; px = cx+rx; py = cy; tp = 0; k = 0;

        for (int i = 0; i <= steps; i++)
        {
            v[k][0] = px; v[k][1] = py; v[k][2] = z2;
            t[k][0] = tp; t[k][1] = 0;
            d3d_model_vertex_texture(id, px, py, z2, tp, 0);
            k++;
            v[k][0] = px; v[k][1] = py; v[k][2] = z1;
            t[k][0] = tp; t[k][1] = vrep;
            d3d_model_vertex_texture(id, px, py, z1, tp, vrep);
            k++; a += pr; px = cx+cos(a)*rx; py = cy+sin(a)*ry; tp += invstep;
        }

        if (closed)
        {
            v[k][0] = cx; v[k][1] = cy; v[k][2] = z1;
            t[k][0] = 0; t[k][1] = vrep;
            k++;
            for (int i = 0; i < steps*2; i+=2)
            {
                d3d_model_vertex_normal_texture(id, cx, cy, z1, 0, 0, -1, 0, vrep);
                d3d_model_vertex_normal_texture(id, v[i+3][0], v[i+3][1], v[i+3][2], 0, 0, -1, t[i+2][0], t[i+2][1]);
                d3d_model_vertex_normal_texture(id, v[i+1][0], v[i+1][1], v[i+1][2], 0, 0, -1, t[i][0], t[i][1]);
            }

            v[k][0] = cx; v[k][1] = cy; v[k][2] = z2;
            t[k][0] = 0; t[k][1] = vrep;
            k++;
            for (int i = 0; i < steps*2; i+=2)
            {
                d3d_model_vertex_normal_texture(id, cx, cy, z2, 0, 0, -1, 0, vrep);
                d3d_model_vertex_normal_texture(id, v[i][0], v[i][1], v[i][2], 0, 0, -1, t[i][0], t[i][1]);
                d3d_model_vertex_normal_texture(id, v[i+2][0], v[i+2][1], v[i+2][2], 0, 0, -1, t[i+2][0], t[i+2][1]);
            }
        }
}

void d3d_model_cone(int id, gs_scalar x1, gs_scalar y1, gs_scalar z1, gs_scalar x2, gs_scalar y2, gs_scalar z2, gs_scalar hrep, gs_scalar vrep, bool closed, int steps)
{
  steps = min(max(steps, 3), 48);
  const double cx = (x1+x2)/2, cy = (y1+y2)/2, rx = (x2-x1)/2, ry = (y2-y1)/2, invstep = (1.0/steps)*hrep, pr = 2*M_PI/steps;
  double a, px, py, tp;
  int k = 0;
  d3d_model_primitive_begin(id, pr_trianglefan);
  d3d_model_vertex_texture(id, cx, cy, z2, 0, 0);
  k++;
  a = 0; px = cx+rx; py = cy; tp = 0;
  for (int i = 0; i <= steps; i++)
  {
    d3d_model_vertex_texture(id, px, py, z1, tp, vrep);
    k++; a += pr; px = cx+cos(a)*rx; py = cy+sin(a)*ry; tp += invstep;
  }
  d3d_model_primitive_end(id);
  if (closed)
  {
    d3d_model_primitive_begin(id, pr_trianglefan);
    d3d_model_vertex_texture(id, cx, cy, z1, 0, vrep);
    k++;
    tp = 0;
    for (int i = 0; i <= steps + 1; i++)
    {
      d3d_model_vertex_texture(id, px, py, z1, tp, 0);
      k++; a -= pr; px = cx+cos(a)*rx; py = cy+sin(a)*ry; tp += invstep;
    }
    d3d_model_primitive_end(id);
  }
}

void d3d_model_ellipsoid(int id, gs_scalar x1, gs_scalar y1, gs_scalar z1, gs_scalar x2, gs_scalar y2, gs_scalar z2, gs_scalar hrep, gs_scalar vrep, int steps)
{
  float v[277][3];
  float t[277][3];
  steps = min(max(steps, 3), 24);
  const int zsteps = ceil(steps/2);
  const double cx = (x1+x2)/2, cy = (y1+y2)/2, cz = (z1+z2)/2, rx = (x2-x1)/2, ry = (y2-y1)/2, rz = (z2-z1)/2, invstep = (1.0/steps)*hrep, invstep2 = (1.0/zsteps)*vrep, pr = 2*M_PI/steps, qr = M_PI/zsteps;
  double a, b, px, py, pz, tp, tzp, cosb;
  double cosx[25], siny[25], txp[25];
  a = pr; tp = 0;
  for (int i = 0; i <= steps; i++)
  {
    cosx[i] = cos(a)*rx; siny[i] = sin(a)*ry;
    txp[i] = tp;
    a += pr; tp += invstep;
  }
  int k = 0, kk;
  d3d_model_primitive_begin(id, pr_trianglefan);
  v[k][0] = cx; v[k][1] = cy; v[k][2] = cz - rz;
  t[k][0] = 0; t[k][1] = vrep;
  d3d_model_vertex_normal_texture(id, cx, cy, cz - rz, cx, cy, cz - rz, 0, vrep);
  k++;
  b = qr-M_PI/2;
  cosb = cos(b);
  pz = rz*sin(b);
  tzp = vrep-invstep2;
  px = cx+rx*cosb; py = cy;
  // BOTTOM
  for (int i = 0; i <= steps; i++)
  {
    v[k][0] = px; v[k][1] = py; v[k][2] = cz + pz;
    t[k][0] = txp[i]; t[k][1] = tzp;
    d3d_model_vertex_normal_texture(id, px, py, cz + pz, px, py, cz + pz, txp[i], tzp);
    k++; px = cx+cosx[i]*cosb; py = cy-siny[i]*cosb;
 }
 d3d_model_primitive_end(id);
 // SIDES
 for (int ii = 0; ii < zsteps - 2; ii++)
 {
    b += qr;
    cosb = cos(b);
	pz = rz*sin(b);
    tzp -= invstep2;
    d3d_model_primitive_begin(id, pr_trianglestrip);
    px = cx+rx*cosb; py = cy;
    for (int i = 0; i <= steps; i++)
    {
        kk = k - steps - 1;
        d3d_model_vertex_normal_texture(id, v[kk][0], v[kk][1], v[kk][2], 0, 0, 0, t[kk][0], t[kk][1]);
        v[k][0] = px; v[k][1] = py; v[k][2] = cz + pz;
        t[k][0] = txp[i]; t[k][1] = tzp;
        d3d_model_vertex_normal_texture(id, px, py, cz + pz, px, py, cz + pz, txp[i], tzp);
        k++; px = cx+cosx[i]*cosb; py = cy-siny[i]*cosb;
    }
    d3d_model_primitive_end(id);
  }
  d3d_model_primitive_begin(id, pr_trianglefan);
  v[k][0] = cx; v[k][1] = cy; v[k][2] = cz + rz;
  t[k][0] = 0; t[k][1] = 0;
  d3d_model_vertex_normal_texture(id, cx, cy, cz + rz, 0,0,0, 0, 0);
  k++;
  // TOP
  for (int i = k - 2; i >= k - steps - 2; i--)
  {
	d3d_model_vertex_normal_texture(id, v[i][0], v[i][1], v[i][2], 0, 0, 0, t[i][0], t[i][1]);
  }
  d3d_model_primitive_end(id);
}

void d3d_model_icosahedron(int id)
{
  //TODO: Write this shit
}

void d3d_model_torus(int id, gs_scalar x1, gs_scalar y1, gs_scalar z1, gs_scalar hrep, gs_scalar vrep, int csteps, int tsteps, double radius, double tradius, double TWOPI)
{
  int numc = csteps, numt = tsteps;

  for (int i = 0; i < numc; i++) {
    d3d_model_primitive_begin(id, pr_trianglestrip); // quads are deprecated all basic shapes on models are batched into primitive 0 as triangle list
    for (int j = 0; j <= numt; j++) {
      for (int k = 1; k >= 0; k--) {

        double s = (i + k) % numc + 0.5;
        double t = j % numt;

        double x = (radius + tradius * cos(s * TWOPI / numc)) * cos(t * TWOPI / numt);
        double y = (radius + tradius * cos(s * TWOPI / numc)) * sin(t * TWOPI / numt);
        double z = tradius * sin(s * TWOPI / numc);
	double u = (i + k) / (float)numc;
	double v = t / (float)numt;

	d3d_model_vertex_texture(id, x1 + x, y1 + y, z1 + z, u, v);
      }
    }
    d3d_model_primitive_end(id);
  }
}

void d3d_model_wall(int id, gs_scalar x1, gs_scalar y1, gs_scalar z1, gs_scalar x2, gs_scalar y2, gs_scalar z2, gs_scalar hrep, gs_scalar vrep)
{
  gs_scalar xd = x2-x1, yd = y2-y1, zd = z2-z1;
  gs_scalar normal[3] = {xd*zd, zd*yd, 0};
  gs_scalar mag = hypot(normal[0], normal[1]);
  normal[0] /= mag;
  normal[1] /= mag;

  d3d_model_primitive_begin(id, pr_trianglestrip);
  d3d_model_vertex_normal_texture(id, x1, y1, z1, normal[0], normal[1], normal[2], 0, 0);
  d3d_model_vertex_normal_texture(id, x2, y2, z1, normal[0], normal[1], normal[2], hrep, 0);
  d3d_model_vertex_normal_texture(id, x1, y1, z2, normal[0], normal[1], normal[2], 0, vrep);
  d3d_model_vertex_normal_texture(id, x2, y2, z2, normal[0], normal[1], normal[2], hrep, vrep);
  d3d_model_primitive_end(id);
}

void d3d_model_floor(int id, gs_scalar x1, gs_scalar y1, gs_scalar z1, gs_scalar x2, gs_scalar y2, gs_scalar z2, gs_scalar hrep, gs_scalar vrep)
{
  gs_scalar normal[] = {0, 0, 1};

  d3d_model_primitive_begin(id, pr_trianglestrip);
  d3d_model_vertex_normal_texture(id, x1, y1, z1, normal[0], normal[1], normal[2], 0, 0);
  d3d_model_vertex_normal_texture(id, x2, y1, z2, normal[0], normal[1], normal[2], 0, vrep);
  d3d_model_vertex_normal_texture(id, x1, y2, z1, normal[0], normal[1], normal[2], hrep, 0);
  d3d_model_vertex_normal_texture(id, x2, y2, z2, normal[0], normal[1], normal[2], hrep, vrep);
  d3d_model_primitive_end(id);
}

}