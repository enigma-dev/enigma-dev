/********************************************************************************\
**                                                                              **
**  Copyright (C) 2008 Josh Ventura                                             **
**                                                                              **
**  This file is a part of the ENIGMA Development Environment.                  **
**                                                                              **
**                                                                              **
**  ENIGMA is free software: you can redistribute it and/or modify it under the **
**  terms of the GNU General Public License as published by the Free Software   **
**  Foundation, version 3 of the license or any later version.                  **
**                                                                              **
**  This application and its source code is distributed AS-IS, WITHOUT ANY      **
**  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   **
**  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       **
**  details.                                                                    **
**                                                                              **
**  You should have recieved a copy of the GNU General Public License along     **
**  with this code. If not, see <http://www.gnu.org/licenses/>                  **
**                                                                              **
**  ENIGMA is an environment designed to create games and other programs with a **
**  high-level, fully compilable language. Developers of ENIGMA or anything     **
**  associated with ENIGMA are in no way responsible for its users or           **
**  applications created by its users, or damages caused by the environment     **
**  or programs made in the environment.                                        **
**                                                                              **
\********************************************************************************/

//This file was generated by the ENIGMA Development Environment.
//Editing it is a sign of a certain medical condition. We're not sure which one.

#include "Universal_System/Object_Tiers/collisions_object.h"
#include "Universal_System/Object_Tiers/object.h"

#include <map>// Script identifiers
#define create_views(...) _SCR_create_views(__VA_ARGS__)


evariant _SCR_create_views(evariant argument0=0, evariant argument1=0, evariant argument2=0, evariant argument3=0, evariant argument4=0, evariant argument5=0, evariant argument6=0, evariant argument7=0, evariant argument8=0, evariant argument9=0, evariant argument10=0, evariant argument11=0, evariant argument12=0, evariant argument13=0, evariant argument14=0, evariant argument15=0);


namespace enigma
{
  extern std::map<int,object_basic*> instance_deactivated_list;
  extern objectstruct** objectdata;

  struct object_locals: event_parent /* HideErrors */,
      virtual extension_alarm,
      virtual extension_path
  {
    #include "Preprocessor_Environment_Editable/IDE_EDIT_inherited_locals.h"

    std::map<string, var> *vmap;
    object_locals() {vmap = NULL;}
    object_locals(unsigned _x, int _y): event_parent(_x,_y) {vmap = NULL;}
  };

  namespace extension_cast {
    extension_alarm *as_extension_alarm(object_basic* x) {
      return (extension_alarm*)(object_locals*)x;
    }
    extension_path *as_extension_path(object_basic* x) {
      return (extension_path*)(object_locals*)x;
    }
  }
}

namespace enigma // TODO: Replace with enigma_user
{
  
  struct OBJ_obj_splash_screen: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    evariant myevent_alarm_1();
    inline bool myevent_alarm_1_subcheck();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      if (type == 2 && numb == 1)
        return myevent_alarm_1();
      if (type == 8 && numb == 0)
        return myevent_draw();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_splash_screen(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 0, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[0]->sprite;
      mask_index = enigma::objectdata[0]->mask;
      visible = enigma::objectdata[0]->visible;
      solid = enigma::objectdata[0]->solid;
      persistent = enigma::objectdata[0]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[0]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_splash_screen()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_title_logo: object_locals
  {
    // Local variables
    var pressed;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    evariant myevent_alarm_1();
    inline bool myevent_alarm_1_subcheck();
    evariant myevent_roomstart();
    evariant myevent_roomend();
    evariant myevent_keypressed_AnyKey();
    evariant myevent_keypressed_Escape();
    evariant myevent_keypressed_Space();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      if (type == 2 && numb == 1)
        return myevent_alarm_1();
      if (type == 7 && numb == 4)
        return myevent_roomstart();
      if (type == 7 && numb == 5)
        return myevent_roomend();
      if (type == 9 && numb == 1)
        return myevent_keypressed_AnyKey();
      if (type == 9 && numb == 27)
        return myevent_keypressed_Escape();
      if (type == 9 && numb == 32)
        return myevent_keypressed_Space();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj1;
      enigma::inst_iter *ENOBJ_ITER_myevent_roomstart;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_AnyKey;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_Escape;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_Space;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_roomend;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj1, 1);
      enigma::event_roomstart->unlink(ENOBJ_ITER_myevent_roomstart);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_keypressed_AnyKey->unlink(ENOBJ_ITER_myevent_keypressed_AnyKey);
      enigma::event_keypressed_Escape->unlink(ENOBJ_ITER_myevent_keypressed_Escape);
      enigma::event_keypressed_Space->unlink(ENOBJ_ITER_myevent_keypressed_Space);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_roomend->unlink(ENOBJ_ITER_myevent_roomend);
    }

    OBJ_obj_title_logo(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 1, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[1]->sprite;
      mask_index = enigma::objectdata[1]->mask;
      visible = enigma::objectdata[1]->visible;
      solid = enigma::objectdata[1]->solid;
      persistent = enigma::objectdata[1]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[1]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj1 = enigma::link_obj_instance(this, 1);
      ENOBJ_ITER_myevent_roomstart = enigma::event_roomstart->add_inst(this);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_AnyKey = enigma::event_keypressed_AnyKey->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_Escape = enigma::event_keypressed_Escape->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_Space = enigma::event_keypressed_Space->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_roomend = enigma::event_roomend->add_inst(this);
    }
    
    ~OBJ_obj_title_logo()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj1;
      delete ENOBJ_ITER_myevent_roomstart;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_keypressed_AnyKey;
      delete ENOBJ_ITER_myevent_keypressed_Escape;
      delete ENOBJ_ITER_myevent_keypressed_Space;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_roomend;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_copyright: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj2;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj2, 2);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_copyright(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 2, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[2]->sprite;
      mask_index = enigma::objectdata[2]->mask;
      visible = enigma::objectdata[2]->visible;
      solid = enigma::objectdata[2]->solid;
      persistent = enigma::objectdata[2]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[2]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj2 = enigma::link_obj_instance(this, 2);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_copyright()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj2;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_love: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj3;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj3, 3);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_love(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 3, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[3]->sprite;
      mask_index = enigma::objectdata[3]->mask;
      visible = enigma::objectdata[3]->visible;
      solid = enigma::objectdata[3]->solid;
      persistent = enigma::objectdata[3]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[3]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj3 = enigma::link_obj_instance(this, 3);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_love()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj3;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_door_top: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj4;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj4, 4);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_door_top(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 4, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[4]->sprite;
      mask_index = enigma::objectdata[4]->mask;
      visible = enigma::objectdata[4]->visible;
      solid = enigma::objectdata[4]->solid;
      persistent = enigma::objectdata[4]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[4]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj4 = enigma::link_obj_instance(this, 4);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_door_top()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj4;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_door_bottom: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj5;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj5, 5);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_door_bottom(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 5, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[5]->sprite;
      mask_index = enigma::objectdata[5]->mask;
      visible = enigma::objectdata[5]->visible;
      solid = enigma::objectdata[5]->solid;
      persistent = enigma::objectdata[5]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[5]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj5 = enigma::link_obj_instance(this, 5);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_door_bottom()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj5;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_doorknob: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj6;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj6, 6);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_doorknob(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 6, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[6]->sprite;
      mask_index = enigma::objectdata[6]->mask;
      visible = enigma::objectdata[6]->visible;
      solid = enigma::objectdata[6]->solid;
      persistent = enigma::objectdata[6]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[6]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj6 = enigma::link_obj_instance(this, 6);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_doorknob()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj6;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_doorway_ver: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj7;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj7, 7);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_doorway_ver(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 7, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[7]->sprite;
      mask_index = enigma::objectdata[7]->mask;
      visible = enigma::objectdata[7]->visible;
      solid = enigma::objectdata[7]->solid;
      persistent = enigma::objectdata[7]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[7]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj7 = enigma::link_obj_instance(this, 7);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_doorway_ver()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj7;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_doorway_hor: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj8;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj8, 8);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_doorway_hor(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 8, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[8]->sprite;
      mask_index = enigma::objectdata[8]->mask;
      visible = enigma::objectdata[8]->visible;
      solid = enigma::objectdata[8]->solid;
      persistent = enigma::objectdata[8]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[8]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj8 = enigma::link_obj_instance(this, 8);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_doorway_hor()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj8;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_doorway_corner_left: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj9;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj9, 9);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_doorway_corner_left(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 9, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[9]->sprite;
      mask_index = enigma::objectdata[9]->mask;
      visible = enigma::objectdata[9]->visible;
      solid = enigma::objectdata[9]->solid;
      persistent = enigma::objectdata[9]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[9]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj9 = enigma::link_obj_instance(this, 9);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_doorway_corner_left()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj9;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_doorway_corner_right: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj10;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj10, 10);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_doorway_corner_right(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 10, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[10]->sprite;
      mask_index = enigma::objectdata[10]->mask;
      visible = enigma::objectdata[10]->visible;
      solid = enigma::objectdata[10]->solid;
      persistent = enigma::objectdata[10]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[10]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj10 = enigma::link_obj_instance(this, 10);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_doorway_corner_right()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj10;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_doorway_bottom: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_doorway_bottom(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 11, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[11]->sprite;
      mask_index = enigma::objectdata[11]->mask;
      visible = enigma::objectdata[11]->visible;
      solid = enigma::objectdata[11]->solid;
      persistent = enigma::objectdata[11]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[11]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_doorway_bottom()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_controller: object_locals
  {
    // Local variables
    var col;
    var i;
    var subimg_index;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    evariant myevent_step();
    evariant myevent_roomend();
    evariant myevent_windowclose();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    evariant myevent_keypressed_Enter();
    evariant myevent_keypressed_F4();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      if (type == 3 && numb == 0)
        return myevent_step();
      if (type == 7 && numb == 5)
        return myevent_roomend();
      if (type == 7 && numb == 30)
        return myevent_windowclose();
      if (type == 8 && numb == 0)
        return myevent_draw();
      if (type == 9 && numb == 13)
        return myevent_keypressed_Enter();
      if (type == 9 && numb == 115)
        return myevent_keypressed_F4();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj13;
      enigma::inst_iter *ENOBJ_ITER_myevent_windowclose;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_Enter;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_F4;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_roomend;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj13, 13);
      enigma::event_windowclose->unlink(ENOBJ_ITER_myevent_windowclose);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_keypressed_Enter->unlink(ENOBJ_ITER_myevent_keypressed_Enter);
      enigma::event_keypressed_F4->unlink(ENOBJ_ITER_myevent_keypressed_F4);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_roomend->unlink(ENOBJ_ITER_myevent_roomend);
    }

    OBJ_obj_controller(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 13, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[13]->sprite;
      mask_index = enigma::objectdata[13]->mask;
      visible = enigma::objectdata[13]->visible;
      solid = enigma::objectdata[13]->solid;
      persistent = enigma::objectdata[13]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[13]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj13 = enigma::link_obj_instance(this, 13);
      ENOBJ_ITER_myevent_windowclose = enigma::event_windowclose->add_inst(this);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_Enter = enigma::event_keypressed_Enter->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_F4 = enigma::event_keypressed_F4->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_roomend = enigma::event_roomend->add_inst(this);
    }
    
    ~OBJ_obj_controller()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj13;
      delete ENOBJ_ITER_myevent_windowclose;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_keypressed_Enter;
      delete ENOBJ_ITER_myevent_keypressed_F4;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_roomend;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_background: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 8 && numb == 0)
        return myevent_draw();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj14;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj14, 14);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_background(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 14, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[14]->sprite;
      mask_index = enigma::objectdata[14]->mask;
      visible = enigma::objectdata[14]->visible;
      solid = enigma::objectdata[14]->solid;
      persistent = enigma::objectdata[14]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[14]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj14 = enigma::link_obj_instance(this, 14);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_background()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj14;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_character: object_locals
  {
    // Local variables
    var allow_multiplayer;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    evariant myevent_step();
    evariant myevent_collision_obj_baddie_parent();
    inline bool myevent_collision_obj_baddie_parent_subcheck();
    evariant myevent_collision_obj_land_parent();
    inline bool myevent_collision_obj_land_parent_subcheck();
    evariant myevent_collision_obj_water_parent();
    inline bool myevent_collision_obj_water_parent_subcheck();
    evariant myevent_collision_obj_door();
    inline bool myevent_collision_obj_door_subcheck();
    evariant myevent_keypressed_Escape();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;
    void myevent_collision_dispatcher() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      if (type == 3 && numb == 0)
        return myevent_step();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_baddie_parent();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_land_parent();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_water_parent();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_door();
      if (type == 9 && numb == 27)
        return myevent_keypressed_Escape();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj15;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_Escape;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj15, 15);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_keypressed_Escape->unlink(ENOBJ_ITER_myevent_keypressed_Escape);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_character(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 15, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[15]->sprite;
      mask_index = enigma::objectdata[15]->mask;
      visible = enigma::objectdata[15]->visible;
      solid = enigma::objectdata[15]->solid;
      persistent = enigma::objectdata[15]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[15]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj15 = enigma::link_obj_instance(this, 15);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_Escape = enigma::event_keypressed_Escape->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_character()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj15;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_keypressed_Escape;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_collision;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_charlittle: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    evariant myevent_step();
    evariant myevent_collision_obj_baddie_parent();
    inline bool myevent_collision_obj_baddie_parent_subcheck();
    evariant myevent_collision_obj_land_parent();
    inline bool myevent_collision_obj_land_parent_subcheck();
    evariant myevent_collision_obj_water_parent();
    inline bool myevent_collision_obj_water_parent_subcheck();
    evariant myevent_collision_obj_door();
    inline bool myevent_collision_obj_door_subcheck();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    evariant myevent_keypressed_Escape();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;
    void myevent_collision_dispatcher() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      if (type == 3 && numb == 0)
        return myevent_step();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_baddie_parent();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_land_parent();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_water_parent();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_door();
      if (type == 8 && numb == 0)
        return myevent_draw();
      if (type == 9 && numb == 27)
        return myevent_keypressed_Escape();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj16;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_Escape;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj16, 16);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_keypressed_Escape->unlink(ENOBJ_ITER_myevent_keypressed_Escape);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_charlittle(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 16, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[16]->sprite;
      mask_index = enigma::objectdata[16]->mask;
      visible = enigma::objectdata[16]->visible;
      solid = enigma::objectdata[16]->solid;
      persistent = enigma::objectdata[16]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[16]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj16 = enigma::link_obj_instance(this, 16);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_Escape = enigma::event_keypressed_Escape->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_charlittle()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj16;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_keypressed_Escape;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_collision;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_char_win: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj17;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj17, 17);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_char_win(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 17, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[17]->sprite;
      mask_index = enigma::objectdata[17]->mask;
      visible = enigma::objectdata[17]->visible;
      solid = enigma::objectdata[17]->solid;
      persistent = enigma::objectdata[17]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[17]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj17 = enigma::link_obj_instance(this, 17);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_char_win()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj17;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_char_lose: object_locals
  {
    // Local variables
    var i;
    var inst;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj18;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj18, 18);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_char_lose(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 18, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[18]->sprite;
      mask_index = enigma::objectdata[18]->mask;
      visible = enigma::objectdata[18]->visible;
      solid = enigma::objectdata[18]->solid;
      persistent = enigma::objectdata[18]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[18]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj18 = enigma::link_obj_instance(this, 18);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_char_lose()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj18;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_charlittle_die: object_locals
  {
    // Local variables
    var i;
    var inst;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj19;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj19, 19);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_charlittle_die(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 19, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[19]->sprite;
      mask_index = enigma::objectdata[19]->mask;
      visible = enigma::objectdata[19]->visible;
      solid = enigma::objectdata[19]->solid;
      persistent = enigma::objectdata[19]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[19]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj19 = enigma::link_obj_instance(this, 19);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_charlittle_die()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj19;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_parent: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj20;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj20, 20);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_baddie_parent(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 20, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[20]->sprite;
      mask_index = enigma::objectdata[20]->mask;
      visible = enigma::objectdata[20]->visible;
      solid = enigma::objectdata[20]->solid;
      persistent = enigma::objectdata[20]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[20]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj20 = enigma::link_obj_instance(this, 20);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_baddie_parent()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj20;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_background_shark: OBJ_obj_baddie_parent
  {
    // Local variables
    var dir;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_step();
    evariant myevent_collision_obj_baddie_barrier();
    inline bool myevent_collision_obj_baddie_barrier_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_collision_dispatcher() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 3 && numb == 0)
        return myevent_step();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_baddie_barrier();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj12;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj12, 12);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }

    OBJ_obj_background_shark(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 12, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[12]->sprite;
      mask_index = enigma::objectdata[12]->mask;
      visible = enigma::objectdata[12]->visible;
      solid = enigma::objectdata[12]->solid;
      persistent = enigma::objectdata[12]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[12]->depth, this);
      ENOBJ_ITER_myobj12 = enigma::link_obj_instance(this, 12);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
    }
    
    ~OBJ_obj_background_shark()
    {
      delete ENOBJ_ITER_myobj12;
      delete ENOBJ_ITER_myevent_collision;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_acid_leak: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      if (type == 8 && numb == 0)
        return myevent_draw();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj37;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj37, 37);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }

    OBJ_obj_baddie_acid_leak(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 37, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[37]->sprite;
      mask_index = enigma::objectdata[37]->mask;
      visible = enigma::objectdata[37]->visible;
      solid = enigma::objectdata[37]->solid;
      persistent = enigma::objectdata[37]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[37]->depth, this);
      ENOBJ_ITER_myobj37 = enigma::link_obj_instance(this, 37);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
    }
    
    ~OBJ_obj_baddie_acid_leak()
    {
      delete ENOBJ_ITER_myobj37;
      delete ENOBJ_ITER_myevent_alarm;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_acid_drop: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_collision_obj_baddie_destroy_acid();
    inline bool myevent_collision_obj_baddie_destroy_acid_subcheck();
    evariant myevent_outsideroom();
    inline bool myevent_outsideroom_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_collision_dispatcher() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_baddie_destroy_acid();
      if (type == 7 && numb == 0)
        return myevent_outsideroom();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj38;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj38, 38);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }

    OBJ_obj_baddie_acid_drop(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 38, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[38]->sprite;
      mask_index = enigma::objectdata[38]->mask;
      visible = enigma::objectdata[38]->visible;
      solid = enigma::objectdata[38]->solid;
      persistent = enigma::objectdata[38]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[38]->depth, this);
      ENOBJ_ITER_myobj38 = enigma::link_obj_instance(this, 38);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
    }
    
    ~OBJ_obj_baddie_acid_drop()
    {
      delete ENOBJ_ITER_myobj38;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_collision;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_acid_man: OBJ_obj_baddie_parent
  {
    // Local variables
    var dir;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_step();
    evariant myevent_collision_obj_baddie_acid_man();
    inline bool myevent_collision_obj_baddie_acid_man_subcheck();
    evariant myevent_collision_obj_baddie_barrier();
    inline bool myevent_collision_obj_baddie_barrier_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_collision_dispatcher() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 3 && numb == 0)
        return myevent_step();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_baddie_acid_man();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_baddie_barrier();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj39;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj39, 39);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }

    OBJ_obj_baddie_acid_man(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 39, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[39]->sprite;
      mask_index = enigma::objectdata[39]->mask;
      visible = enigma::objectdata[39]->visible;
      solid = enigma::objectdata[39]->solid;
      persistent = enigma::objectdata[39]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[39]->depth, this);
      ENOBJ_ITER_myobj39 = enigma::link_obj_instance(this, 39);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
    }
    
    ~OBJ_obj_baddie_acid_man()
    {
      delete ENOBJ_ITER_myobj39;
      delete ENOBJ_ITER_myevent_collision;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_spikes_up: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj40;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj40, 40);
    }

    OBJ_obj_baddie_spikes_up(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 40, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[40]->sprite;
      mask_index = enigma::objectdata[40]->mask;
      visible = enigma::objectdata[40]->visible;
      solid = enigma::objectdata[40]->solid;
      persistent = enigma::objectdata[40]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[40]->depth, this);
      ENOBJ_ITER_myobj40 = enigma::link_obj_instance(this, 40);
    }
    
    ~OBJ_obj_baddie_spikes_up()
    {
      delete ENOBJ_ITER_myobj40;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_spikes_down: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj41;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj41, 41);
    }

    OBJ_obj_baddie_spikes_down(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 41, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[41]->sprite;
      mask_index = enigma::objectdata[41]->mask;
      visible = enigma::objectdata[41]->visible;
      solid = enigma::objectdata[41]->solid;
      persistent = enigma::objectdata[41]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[41]->depth, this);
      ENOBJ_ITER_myobj41 = enigma::link_obj_instance(this, 41);
    }
    
    ~OBJ_obj_baddie_spikes_down()
    {
      delete ENOBJ_ITER_myobj41;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_trap_up: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj52;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj52, 52);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }

    OBJ_obj_baddie_trap_up(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 52, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[52]->sprite;
      mask_index = enigma::objectdata[52]->mask;
      visible = enigma::objectdata[52]->visible;
      solid = enigma::objectdata[52]->solid;
      persistent = enigma::objectdata[52]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[52]->depth, this);
      ENOBJ_ITER_myobj52 = enigma::link_obj_instance(this, 52);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
    }
    
    ~OBJ_obj_baddie_trap_up()
    {
      delete ENOBJ_ITER_myobj52;
      delete ENOBJ_ITER_myevent_alarm;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_trap_down: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj53;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj53, 53);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }

    OBJ_obj_baddie_trap_down(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 53, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[53]->sprite;
      mask_index = enigma::objectdata[53]->mask;
      visible = enigma::objectdata[53]->visible;
      solid = enigma::objectdata[53]->solid;
      persistent = enigma::objectdata[53]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[53]->depth, this);
      ENOBJ_ITER_myobj53 = enigma::link_obj_instance(this, 53);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
    }
    
    ~OBJ_obj_baddie_trap_down()
    {
      delete ENOBJ_ITER_myobj53;
      delete ENOBJ_ITER_myevent_alarm;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_trap_left: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_collision_obj_baddie_destroy_trap();
    inline bool myevent_collision_obj_baddie_destroy_trap_subcheck();
    evariant myevent_outsideroom();
    inline bool myevent_outsideroom_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_collision_dispatcher() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_baddie_destroy_trap();
      if (type == 7 && numb == 0)
        return myevent_outsideroom();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj54;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj54, 54);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }

    OBJ_obj_baddie_trap_left(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 54, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[54]->sprite;
      mask_index = enigma::objectdata[54]->mask;
      visible = enigma::objectdata[54]->visible;
      solid = enigma::objectdata[54]->solid;
      persistent = enigma::objectdata[54]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[54]->depth, this);
      ENOBJ_ITER_myobj54 = enigma::link_obj_instance(this, 54);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
    }
    
    ~OBJ_obj_baddie_trap_left()
    {
      delete ENOBJ_ITER_myobj54;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_collision;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_trap_right: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_collision_obj_baddie_destroy_trap();
    inline bool myevent_collision_obj_baddie_destroy_trap_subcheck();
    evariant myevent_outsideroom();
    inline bool myevent_outsideroom_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_collision_dispatcher() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_baddie_destroy_trap();
      if (type == 7 && numb == 0)
        return myevent_outsideroom();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj55;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj55, 55);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }

    OBJ_obj_baddie_trap_right(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 55, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[55]->sprite;
      mask_index = enigma::objectdata[55]->mask;
      visible = enigma::objectdata[55]->visible;
      solid = enigma::objectdata[55]->solid;
      persistent = enigma::objectdata[55]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[55]->depth, this);
      ENOBJ_ITER_myobj55 = enigma::link_obj_instance(this, 55);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
    }
    
    ~OBJ_obj_baddie_trap_right()
    {
      delete ENOBJ_ITER_myobj55;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_collision;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_shark: OBJ_obj_baddie_parent
  {
    // Local variables
    var dir;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_step();
    evariant myevent_collision_obj_baddie_barrier();
    inline bool myevent_collision_obj_baddie_barrier_subcheck();
    evariant myevent_collision_obj_baddie_shark();
    inline bool myevent_collision_obj_baddie_shark_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_collision_dispatcher() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 3 && numb == 0)
        return myevent_step();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_baddie_barrier();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_baddie_shark();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj61;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj61, 61);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }

    OBJ_obj_baddie_shark(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 61, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[61]->sprite;
      mask_index = enigma::objectdata[61]->mask;
      visible = enigma::objectdata[61]->visible;
      solid = enigma::objectdata[61]->solid;
      persistent = enigma::objectdata[61]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[61]->depth, this);
      ENOBJ_ITER_myobj61 = enigma::link_obj_instance(this, 61);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
    }
    
    ~OBJ_obj_baddie_shark()
    {
      delete ENOBJ_ITER_myobj61;
      delete ENOBJ_ITER_myevent_collision;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_buzz_saw_1: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj71;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj71, 71);
    }

    OBJ_obj_baddie_buzz_saw_1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 71, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[71]->sprite;
      mask_index = enigma::objectdata[71]->mask;
      visible = enigma::objectdata[71]->visible;
      solid = enigma::objectdata[71]->solid;
      persistent = enigma::objectdata[71]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[71]->depth, this);
      ENOBJ_ITER_myobj71 = enigma::link_obj_instance(this, 71);
    }
    
    ~OBJ_obj_baddie_buzz_saw_1()
    {
      delete ENOBJ_ITER_myobj71;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_buzz_saw_2: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj72;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj72, 72);
    }

    OBJ_obj_baddie_buzz_saw_2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 72, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[72]->sprite;
      mask_index = enigma::objectdata[72]->mask;
      visible = enigma::objectdata[72]->visible;
      solid = enigma::objectdata[72]->solid;
      persistent = enigma::objectdata[72]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[72]->depth, this);
      ENOBJ_ITER_myobj72 = enigma::link_obj_instance(this, 72);
    }
    
    ~OBJ_obj_baddie_buzz_saw_2()
    {
      delete ENOBJ_ITER_myobj72;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_buzz_saw_3: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj73;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj73, 73);
    }

    OBJ_obj_baddie_buzz_saw_3(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 73, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[73]->sprite;
      mask_index = enigma::objectdata[73]->mask;
      visible = enigma::objectdata[73]->visible;
      solid = enigma::objectdata[73]->solid;
      persistent = enigma::objectdata[73]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[73]->depth, this);
      ENOBJ_ITER_myobj73 = enigma::link_obj_instance(this, 73);
    }
    
    ~OBJ_obj_baddie_buzz_saw_3()
    {
      delete ENOBJ_ITER_myobj73;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_buzz_saw_4: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj74;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj74, 74);
    }

    OBJ_obj_baddie_buzz_saw_4(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 74, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[74]->sprite;
      mask_index = enigma::objectdata[74]->mask;
      visible = enigma::objectdata[74]->visible;
      solid = enigma::objectdata[74]->solid;
      persistent = enigma::objectdata[74]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[74]->depth, this);
      ENOBJ_ITER_myobj74 = enigma::link_obj_instance(this, 74);
    }
    
    ~OBJ_obj_baddie_buzz_saw_4()
    {
      delete ENOBJ_ITER_myobj74;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_buzz_saw_5: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj75;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj75, 75);
    }

    OBJ_obj_baddie_buzz_saw_5(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 75, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[75]->sprite;
      mask_index = enigma::objectdata[75]->mask;
      visible = enigma::objectdata[75]->visible;
      solid = enigma::objectdata[75]->solid;
      persistent = enigma::objectdata[75]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[75]->depth, this);
      ENOBJ_ITER_myobj75 = enigma::link_obj_instance(this, 75);
    }
    
    ~OBJ_obj_baddie_buzz_saw_5()
    {
      delete ENOBJ_ITER_myobj75;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_buzz_saw_6: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj76;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj76, 76);
    }

    OBJ_obj_baddie_buzz_saw_6(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 76, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[76]->sprite;
      mask_index = enigma::objectdata[76]->mask;
      visible = enigma::objectdata[76]->visible;
      solid = enigma::objectdata[76]->solid;
      persistent = enigma::objectdata[76]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[76]->depth, this);
      ENOBJ_ITER_myobj76 = enigma::link_obj_instance(this, 76);
    }
    
    ~OBJ_obj_baddie_buzz_saw_6()
    {
      delete ENOBJ_ITER_myobj76;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_spike_ball_small_left: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_step();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 3 && numb == 0)
        return myevent_step();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj77;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj77, 77);
    }

    OBJ_obj_baddie_spike_ball_small_left(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 77, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[77]->sprite;
      mask_index = enigma::objectdata[77]->mask;
      visible = enigma::objectdata[77]->visible;
      solid = enigma::objectdata[77]->solid;
      persistent = enigma::objectdata[77]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[77]->depth, this);
      ENOBJ_ITER_myobj77 = enigma::link_obj_instance(this, 77);
    }
    
    ~OBJ_obj_baddie_spike_ball_small_left()
    {
      delete ENOBJ_ITER_myobj77;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_spike_ball_small_right: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_step();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 3 && numb == 0)
        return myevent_step();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj78;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj78, 78);
    }

    OBJ_obj_baddie_spike_ball_small_right(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 78, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[78]->sprite;
      mask_index = enigma::objectdata[78]->mask;
      visible = enigma::objectdata[78]->visible;
      solid = enigma::objectdata[78]->solid;
      persistent = enigma::objectdata[78]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[78]->depth, this);
      ENOBJ_ITER_myobj78 = enigma::link_obj_instance(this, 78);
    }
    
    ~OBJ_obj_baddie_spike_ball_small_right()
    {
      delete ENOBJ_ITER_myobj78;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_spike_ball_large_left: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_step();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 3 && numb == 0)
        return myevent_step();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj79;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj79, 79);
    }

    OBJ_obj_baddie_spike_ball_large_left(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 79, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[79]->sprite;
      mask_index = enigma::objectdata[79]->mask;
      visible = enigma::objectdata[79]->visible;
      solid = enigma::objectdata[79]->solid;
      persistent = enigma::objectdata[79]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[79]->depth, this);
      ENOBJ_ITER_myobj79 = enigma::link_obj_instance(this, 79);
    }
    
    ~OBJ_obj_baddie_spike_ball_large_left()
    {
      delete ENOBJ_ITER_myobj79;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_spike_ball_large_right: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_step();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 3 && numb == 0)
        return myevent_step();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj80;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj80, 80);
    }

    OBJ_obj_baddie_spike_ball_large_right(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 80, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[80]->sprite;
      mask_index = enigma::objectdata[80]->mask;
      visible = enigma::objectdata[80]->visible;
      solid = enigma::objectdata[80]->solid;
      persistent = enigma::objectdata[80]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[80]->depth, this);
      ENOBJ_ITER_myobj80 = enigma::link_obj_instance(this, 80);
    }
    
    ~OBJ_obj_baddie_spike_ball_large_right()
    {
      delete ENOBJ_ITER_myobj80;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_fire: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj81;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj81, 81);
    }

    OBJ_obj_baddie_fire(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 81, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[81]->sprite;
      mask_index = enigma::objectdata[81]->mask;
      visible = enigma::objectdata[81]->visible;
      solid = enigma::objectdata[81]->solid;
      persistent = enigma::objectdata[81]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[81]->depth, this);
      ENOBJ_ITER_myobj81 = enigma::link_obj_instance(this, 81);
    }
    
    ~OBJ_obj_baddie_fire()
    {
      delete ENOBJ_ITER_myobj81;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_lava: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj82;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj82, 82);
    }

    OBJ_obj_baddie_lava(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 82, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[82]->sprite;
      mask_index = enigma::objectdata[82]->mask;
      visible = enigma::objectdata[82]->visible;
      solid = enigma::objectdata[82]->solid;
      persistent = enigma::objectdata[82]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[82]->depth, this);
      ENOBJ_ITER_myobj82 = enigma::link_obj_instance(this, 82);
    }
    
    ~OBJ_obj_baddie_lava()
    {
      delete ENOBJ_ITER_myobj82;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_fire_ball_short: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    evariant myevent_step();
    evariant myevent_collision_obj_land_parent();
    inline bool myevent_collision_obj_land_parent_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;
    void myevent_collision_dispatcher() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      if (type == 3 && numb == 0)
        return myevent_step();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_land_parent();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj83;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj83, 83);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }

    OBJ_obj_baddie_fire_ball_short(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 83, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[83]->sprite;
      mask_index = enigma::objectdata[83]->mask;
      visible = enigma::objectdata[83]->visible;
      solid = enigma::objectdata[83]->solid;
      persistent = enigma::objectdata[83]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[83]->depth, this);
      ENOBJ_ITER_myobj83 = enigma::link_obj_instance(this, 83);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
    }
    
    ~OBJ_obj_baddie_fire_ball_short()
    {
      delete ENOBJ_ITER_myobj83;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_fire_ball_tall: OBJ_obj_baddie_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    evariant myevent_step();
    evariant myevent_collision_obj_land_parent();
    inline bool myevent_collision_obj_land_parent_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;
    void myevent_collision_dispatcher() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      if (type == 3 && numb == 0)
        return myevent_step();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_land_parent();
      return OBJ_obj_baddie_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj84;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_baddie_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj84, 84);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }

    OBJ_obj_baddie_fire_ball_tall(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 84, bool handle = true): OBJ_obj_baddie_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[84]->sprite;
      mask_index = enigma::objectdata[84]->mask;
      visible = enigma::objectdata[84]->visible;
      solid = enigma::objectdata[84]->solid;
      persistent = enigma::objectdata[84]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_baddie_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[84]->depth, this);
      ENOBJ_ITER_myobj84 = enigma::link_obj_instance(this, 84);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
    }
    
    ~OBJ_obj_baddie_fire_ball_tall()
    {
      delete ENOBJ_ITER_myobj84;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_land_parent: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj21;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj21, 21);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_land_parent(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 21, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[21]->sprite;
      mask_index = enigma::objectdata[21]->mask;
      visible = enigma::objectdata[21]->visible;
      solid = enigma::objectdata[21]->solid;
      persistent = enigma::objectdata[21]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[21]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj21 = enigma::link_obj_instance(this, 21);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_land_parent()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj21;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_brick: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj32;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj32, 32);
    }

    OBJ_obj_brick(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 32, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[32]->sprite;
      mask_index = enigma::objectdata[32]->mask;
      visible = enigma::objectdata[32]->visible;
      solid = enigma::objectdata[32]->solid;
      persistent = enigma::objectdata[32]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[32]->depth, this);
      ENOBJ_ITER_myobj32 = enigma::link_obj_instance(this, 32);
    }
    
    ~OBJ_obj_brick()
    {
      delete ENOBJ_ITER_myobj32;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_brick_hor: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj33;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj33, 33);
    }

    OBJ_obj_brick_hor(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 33, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[33]->sprite;
      mask_index = enigma::objectdata[33]->mask;
      visible = enigma::objectdata[33]->visible;
      solid = enigma::objectdata[33]->solid;
      persistent = enigma::objectdata[33]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[33]->depth, this);
      ENOBJ_ITER_myobj33 = enigma::link_obj_instance(this, 33);
    }
    
    ~OBJ_obj_brick_hor()
    {
      delete ENOBJ_ITER_myobj33;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_brick_ver: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj34;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj34, 34);
    }

    OBJ_obj_brick_ver(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 34, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[34]->sprite;
      mask_index = enigma::objectdata[34]->mask;
      visible = enigma::objectdata[34]->visible;
      solid = enigma::objectdata[34]->solid;
      persistent = enigma::objectdata[34]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[34]->depth, this);
      ENOBJ_ITER_myobj34 = enigma::link_obj_instance(this, 34);
    }
    
    ~OBJ_obj_brick_ver()
    {
      delete ENOBJ_ITER_myobj34;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_brick_mid: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj35;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj35, 35);
    }

    OBJ_obj_brick_mid(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 35, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[35]->sprite;
      mask_index = enigma::objectdata[35]->mask;
      visible = enigma::objectdata[35]->visible;
      solid = enigma::objectdata[35]->solid;
      persistent = enigma::objectdata[35]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[35]->depth, this);
      ENOBJ_ITER_myobj35 = enigma::link_obj_instance(this, 35);
    }
    
    ~OBJ_obj_brick_mid()
    {
      delete ENOBJ_ITER_myobj35;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_destroy_acid: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj36;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj36, 36);
    }

    OBJ_obj_baddie_destroy_acid(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 36, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[36]->sprite;
      mask_index = enigma::objectdata[36]->mask;
      visible = enigma::objectdata[36]->visible;
      solid = enigma::objectdata[36]->solid;
      persistent = enigma::objectdata[36]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[36]->depth, this);
      ENOBJ_ITER_myobj36 = enigma::link_obj_instance(this, 36);
    }
    
    ~OBJ_obj_baddie_destroy_acid()
    {
      delete ENOBJ_ITER_myobj36;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_wood: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj43;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj43, 43);
    }

    OBJ_obj_wood(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 43, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[43]->sprite;
      mask_index = enigma::objectdata[43]->mask;
      visible = enigma::objectdata[43]->visible;
      solid = enigma::objectdata[43]->solid;
      persistent = enigma::objectdata[43]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[43]->depth, this);
      ENOBJ_ITER_myobj43 = enigma::link_obj_instance(this, 43);
    }
    
    ~OBJ_obj_wood()
    {
      delete ENOBJ_ITER_myobj43;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_wood_hor: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj44;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj44, 44);
    }

    OBJ_obj_wood_hor(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 44, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[44]->sprite;
      mask_index = enigma::objectdata[44]->mask;
      visible = enigma::objectdata[44]->visible;
      solid = enigma::objectdata[44]->solid;
      persistent = enigma::objectdata[44]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[44]->depth, this);
      ENOBJ_ITER_myobj44 = enigma::link_obj_instance(this, 44);
    }
    
    ~OBJ_obj_wood_hor()
    {
      delete ENOBJ_ITER_myobj44;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_wood_ver: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj45;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj45, 45);
    }

    OBJ_obj_wood_ver(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 45, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[45]->sprite;
      mask_index = enigma::objectdata[45]->mask;
      visible = enigma::objectdata[45]->visible;
      solid = enigma::objectdata[45]->solid;
      persistent = enigma::objectdata[45]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[45]->depth, this);
      ENOBJ_ITER_myobj45 = enigma::link_obj_instance(this, 45);
    }
    
    ~OBJ_obj_wood_ver()
    {
      delete ENOBJ_ITER_myobj45;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_wood_mid: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj46;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj46, 46);
    }

    OBJ_obj_wood_mid(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 46, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[46]->sprite;
      mask_index = enigma::objectdata[46]->mask;
      visible = enigma::objectdata[46]->visible;
      solid = enigma::objectdata[46]->solid;
      persistent = enigma::objectdata[46]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[46]->depth, this);
      ENOBJ_ITER_myobj46 = enigma::link_obj_instance(this, 46);
    }
    
    ~OBJ_obj_wood_mid()
    {
      delete ENOBJ_ITER_myobj46;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_destroy_trap: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj47;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj47, 47);
    }

    OBJ_obj_baddie_destroy_trap(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 47, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[47]->sprite;
      mask_index = enigma::objectdata[47]->mask;
      visible = enigma::objectdata[47]->visible;
      solid = enigma::objectdata[47]->solid;
      persistent = enigma::objectdata[47]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[47]->depth, this);
      ENOBJ_ITER_myobj47 = enigma::link_obj_instance(this, 47);
    }
    
    ~OBJ_obj_baddie_destroy_trap()
    {
      delete ENOBJ_ITER_myobj47;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_coral: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj57;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj57, 57);
    }

    OBJ_obj_coral(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 57, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[57]->sprite;
      mask_index = enigma::objectdata[57]->mask;
      visible = enigma::objectdata[57]->visible;
      solid = enigma::objectdata[57]->solid;
      persistent = enigma::objectdata[57]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[57]->depth, this);
      ENOBJ_ITER_myobj57 = enigma::link_obj_instance(this, 57);
    }
    
    ~OBJ_obj_coral()
    {
      delete ENOBJ_ITER_myobj57;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_coral_hor: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj58;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj58, 58);
    }

    OBJ_obj_coral_hor(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 58, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[58]->sprite;
      mask_index = enigma::objectdata[58]->mask;
      visible = enigma::objectdata[58]->visible;
      solid = enigma::objectdata[58]->solid;
      persistent = enigma::objectdata[58]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[58]->depth, this);
      ENOBJ_ITER_myobj58 = enigma::link_obj_instance(this, 58);
    }
    
    ~OBJ_obj_coral_hor()
    {
      delete ENOBJ_ITER_myobj58;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_coral_ver: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj59;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj59, 59);
    }

    OBJ_obj_coral_ver(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 59, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[59]->sprite;
      mask_index = enigma::objectdata[59]->mask;
      visible = enigma::objectdata[59]->visible;
      solid = enigma::objectdata[59]->solid;
      persistent = enigma::objectdata[59]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[59]->depth, this);
      ENOBJ_ITER_myobj59 = enigma::link_obj_instance(this, 59);
    }
    
    ~OBJ_obj_coral_ver()
    {
      delete ENOBJ_ITER_myobj59;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_coral_mid: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj60;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj60, 60);
    }

    OBJ_obj_coral_mid(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 60, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[60]->sprite;
      mask_index = enigma::objectdata[60]->mask;
      visible = enigma::objectdata[60]->visible;
      solid = enigma::objectdata[60]->solid;
      persistent = enigma::objectdata[60]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[60]->depth, this);
      ENOBJ_ITER_myobj60 = enigma::link_obj_instance(this, 60);
    }
    
    ~OBJ_obj_coral_mid()
    {
      delete ENOBJ_ITER_myobj60;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_rock: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj62;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj62, 62);
    }

    OBJ_obj_rock(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 62, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[62]->sprite;
      mask_index = enigma::objectdata[62]->mask;
      visible = enigma::objectdata[62]->visible;
      solid = enigma::objectdata[62]->solid;
      persistent = enigma::objectdata[62]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[62]->depth, this);
      ENOBJ_ITER_myobj62 = enigma::link_obj_instance(this, 62);
    }
    
    ~OBJ_obj_rock()
    {
      delete ENOBJ_ITER_myobj62;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_rock_hor: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj63;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj63, 63);
    }

    OBJ_obj_rock_hor(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 63, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[63]->sprite;
      mask_index = enigma::objectdata[63]->mask;
      visible = enigma::objectdata[63]->visible;
      solid = enigma::objectdata[63]->solid;
      persistent = enigma::objectdata[63]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[63]->depth, this);
      ENOBJ_ITER_myobj63 = enigma::link_obj_instance(this, 63);
    }
    
    ~OBJ_obj_rock_hor()
    {
      delete ENOBJ_ITER_myobj63;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_rock_ver: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj64;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj64, 64);
    }

    OBJ_obj_rock_ver(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 64, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[64]->sprite;
      mask_index = enigma::objectdata[64]->mask;
      visible = enigma::objectdata[64]->visible;
      solid = enigma::objectdata[64]->solid;
      persistent = enigma::objectdata[64]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[64]->depth, this);
      ENOBJ_ITER_myobj64 = enigma::link_obj_instance(this, 64);
    }
    
    ~OBJ_obj_rock_ver()
    {
      delete ENOBJ_ITER_myobj64;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_rock_mid: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj65;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj65, 65);
    }

    OBJ_obj_rock_mid(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 65, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[65]->sprite;
      mask_index = enigma::objectdata[65]->mask;
      visible = enigma::objectdata[65]->visible;
      solid = enigma::objectdata[65]->solid;
      persistent = enigma::objectdata[65]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[65]->depth, this);
      ENOBJ_ITER_myobj65 = enigma::link_obj_instance(this, 65);
    }
    
    ~OBJ_obj_rock_mid()
    {
      delete ENOBJ_ITER_myobj65;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_rock_hor_large: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj66;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj66, 66);
    }

    OBJ_obj_rock_hor_large(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 66, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[66]->sprite;
      mask_index = enigma::objectdata[66]->mask;
      visible = enigma::objectdata[66]->visible;
      solid = enigma::objectdata[66]->solid;
      persistent = enigma::objectdata[66]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[66]->depth, this);
      ENOBJ_ITER_myobj66 = enigma::link_obj_instance(this, 66);
    }
    
    ~OBJ_obj_rock_hor_large()
    {
      delete ENOBJ_ITER_myobj66;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_rock_ver_large: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj67;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj67, 67);
    }

    OBJ_obj_rock_ver_large(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 67, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[67]->sprite;
      mask_index = enigma::objectdata[67]->mask;
      visible = enigma::objectdata[67]->visible;
      solid = enigma::objectdata[67]->solid;
      persistent = enigma::objectdata[67]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[67]->depth, this);
      ENOBJ_ITER_myobj67 = enigma::link_obj_instance(this, 67);
    }
    
    ~OBJ_obj_rock_ver_large()
    {
      delete ENOBJ_ITER_myobj67;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_rock_mid_large: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj68;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj68, 68);
    }

    OBJ_obj_rock_mid_large(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 68, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[68]->sprite;
      mask_index = enigma::objectdata[68]->mask;
      visible = enigma::objectdata[68]->visible;
      solid = enigma::objectdata[68]->solid;
      persistent = enigma::objectdata[68]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[68]->depth, this);
      ENOBJ_ITER_myobj68 = enigma::link_obj_instance(this, 68);
    }
    
    ~OBJ_obj_rock_mid_large()
    {
      delete ENOBJ_ITER_myobj68;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_rock_mid_large_hor: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj69;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj69, 69);
    }

    OBJ_obj_rock_mid_large_hor(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 69, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[69]->sprite;
      mask_index = enigma::objectdata[69]->mask;
      visible = enigma::objectdata[69]->visible;
      solid = enigma::objectdata[69]->solid;
      persistent = enigma::objectdata[69]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[69]->depth, this);
      ENOBJ_ITER_myobj69 = enigma::link_obj_instance(this, 69);
    }
    
    ~OBJ_obj_rock_mid_large_hor()
    {
      delete ENOBJ_ITER_myobj69;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_rock_mid_large_ver: OBJ_obj_land_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return OBJ_obj_land_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj70;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_land_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj70, 70);
    }

    OBJ_obj_rock_mid_large_ver(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 70, bool handle = true): OBJ_obj_land_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[70]->sprite;
      mask_index = enigma::objectdata[70]->mask;
      visible = enigma::objectdata[70]->visible;
      solid = enigma::objectdata[70]->solid;
      persistent = enigma::objectdata[70]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_land_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[70]->depth, this);
      ENOBJ_ITER_myobj70 = enigma::link_obj_instance(this, 70);
    }
    
    ~OBJ_obj_rock_mid_large_ver()
    {
      delete ENOBJ_ITER_myobj70;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_water_parent: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj22;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj22, 22);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_water_parent(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 22, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[22]->sprite;
      mask_index = enigma::objectdata[22]->mask;
      visible = enigma::objectdata[22]->visible;
      solid = enigma::objectdata[22]->solid;
      persistent = enigma::objectdata[22]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[22]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj22 = enigma::link_obj_instance(this, 22);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_water_parent()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj22;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_water_base: OBJ_obj_water_parent
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return OBJ_obj_water_parent::myevents_perf(type,numb);
    }

    // Self-tracking
      enigma::inst_iter *ENOBJ_ITER_myobj30;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      OBJ_obj_water_parent::deactivate();
      unlink_object_id_iter(ENOBJ_ITER_myobj30, 30);
    }

    OBJ_obj_water_base(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 30, bool handle = true): OBJ_obj_water_parent(enigma_genericconstructor_newinst_x,enigma_genericconstructor_newinst_y,id,enigma_genericobjid,false)
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[30]->sprite;
      mask_index = enigma::objectdata[30]->mask;
      visible = enigma::objectdata[30]->visible;
      solid = enigma::objectdata[30]->solid;
      persistent = enigma::objectdata[30]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      OBJ_obj_water_parent::activate();
      depth.remove();
      depth.init(enigma::objectdata[30]->depth, this);
      ENOBJ_ITER_myobj30 = enigma::link_obj_instance(this, 30);
    }
    
    ~OBJ_obj_water_base()
    {
      delete ENOBJ_ITER_myobj30;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_key: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_collision_obj_character();
    inline bool myevent_collision_obj_character_subcheck();
    evariant myevent_collision_obj_charlittle();
    inline bool myevent_collision_obj_charlittle_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_collision_dispatcher() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_character();
      if (type == 4 && numb == 0)
        return myevent_collision_obj_charlittle();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj23;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj23, 23);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_key(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 23, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[23]->sprite;
      mask_index = enigma::objectdata[23]->mask;
      visible = enigma::objectdata[23]->visible;
      solid = enigma::objectdata[23]->solid;
      persistent = enigma::objectdata[23]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[23]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj23 = enigma::link_obj_instance(this, 23);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_key()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj23;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_collision;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_door: object_locals
  {
    // Local variables
    var nextlevel;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_step();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 3 && numb == 0)
        return myevent_step();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj24;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj24, 24);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_door(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 24, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[24]->sprite;
      mask_index = enigma::objectdata[24]->mask;
      visible = enigma::objectdata[24]->visible;
      solid = enigma::objectdata[24]->solid;
      persistent = enigma::objectdata[24]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[24]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj24 = enigma::link_obj_instance(this, 24);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_door()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj24;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_sparkle: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj25;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj25, 25);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_sparkle(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 25, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[25]->sprite;
      mask_index = enigma::objectdata[25]->mask;
      visible = enigma::objectdata[25]->visible;
      solid = enigma::objectdata[25]->solid;
      persistent = enigma::objectdata[25]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[25]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj25 = enigma::link_obj_instance(this, 25);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_sparkle()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj25;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_sparklittle: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj26;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj26, 26);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_sparklittle(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 26, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[26]->sprite;
      mask_index = enigma::objectdata[26]->mask;
      visible = enigma::objectdata[26]->visible;
      solid = enigma::objectdata[26]->solid;
      persistent = enigma::objectdata[26]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[26]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj26 = enigma::link_obj_instance(this, 26);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_sparklittle()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj26;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_ladder: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj27;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj27, 27);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_ladder(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 27, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[27]->sprite;
      mask_index = enigma::objectdata[27]->mask;
      visible = enigma::objectdata[27]->visible;
      solid = enigma::objectdata[27]->solid;
      persistent = enigma::objectdata[27]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[27]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj27 = enigma::link_obj_instance(this, 27);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_ladder()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj27;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_water_outline: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj28;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj28, 28);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_water_outline(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 28, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[28]->sprite;
      mask_index = enigma::objectdata[28]->mask;
      visible = enigma::objectdata[28]->visible;
      solid = enigma::objectdata[28]->solid;
      persistent = enigma::objectdata[28]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[28]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj28 = enigma::link_obj_instance(this, 28);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_water_outline()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj28;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_water_top: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj29;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj29, 29);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_water_top(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 29, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[29]->sprite;
      mask_index = enigma::objectdata[29]->mask;
      visible = enigma::objectdata[29]->visible;
      solid = enigma::objectdata[29]->solid;
      persistent = enigma::objectdata[29]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[29]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj29 = enigma::link_obj_instance(this, 29);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_water_top()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj29;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_paused: object_locals
  {
    // Local variables
    var PausedBG;
    var ready;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_destroy();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    evariant myevent_gameend();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    evariant myevent_keypressed_Escape();
    evariant myevent_keyreleased_Space();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 1 && numb == 0)
        return myevent_destroy();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      if (type == 7 && numb == 3)
        return myevent_gameend();
      if (type == 8 && numb == 0)
        return myevent_draw();
      if (type == 9 && numb == 27)
        return myevent_keypressed_Escape();
      if (type == 10 && numb == 32)
        return myevent_keyreleased_Space();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj31;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_Escape;
      enigma::inst_iter *ENOBJ_ITER_myevent_keyreleased_Space;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_gameend;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj31, 31);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_keypressed_Escape->unlink(ENOBJ_ITER_myevent_keypressed_Escape);
      enigma::event_keyreleased_Space->unlink(ENOBJ_ITER_myevent_keyreleased_Space);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_gameend->unlink(ENOBJ_ITER_myevent_gameend);
    }

    OBJ_obj_paused(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 31, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[31]->sprite;
      mask_index = enigma::objectdata[31]->mask;
      visible = enigma::objectdata[31]->visible;
      solid = enigma::objectdata[31]->solid;
      persistent = enigma::objectdata[31]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[31]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj31 = enigma::link_obj_instance(this, 31);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_Escape = enigma::event_keypressed_Escape->add_inst(this);
      ENOBJ_ITER_myevent_keyreleased_Space = enigma::event_keyreleased_Space->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_gameend = enigma::event_gameend->add_inst(this);
    }
    
    ~OBJ_obj_paused()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj31;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_keypressed_Escape;
      delete ENOBJ_ITER_myevent_keyreleased_Space;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_gameend;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_barrier: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj42;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj42, 42);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_baddie_barrier(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 42, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[42]->sprite;
      mask_index = enigma::objectdata[42]->mask;
      visible = enigma::objectdata[42]->visible;
      solid = enigma::objectdata[42]->solid;
      persistent = enigma::objectdata[42]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[42]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj42 = enigma::link_obj_instance(this, 42);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_baddie_barrier()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj42;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_trap_up_gen: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 8 && numb == 0)
        return myevent_draw();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj48;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj48, 48);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_baddie_trap_up_gen(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 48, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[48]->sprite;
      mask_index = enigma::objectdata[48]->mask;
      visible = enigma::objectdata[48]->visible;
      solid = enigma::objectdata[48]->solid;
      persistent = enigma::objectdata[48]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[48]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj48 = enigma::link_obj_instance(this, 48);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_baddie_trap_up_gen()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj48;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_trap_down_gen: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 8 && numb == 0)
        return myevent_draw();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj49;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj49, 49);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_baddie_trap_down_gen(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 49, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[49]->sprite;
      mask_index = enigma::objectdata[49]->mask;
      visible = enigma::objectdata[49]->visible;
      solid = enigma::objectdata[49]->solid;
      persistent = enigma::objectdata[49]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[49]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj49 = enigma::link_obj_instance(this, 49);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_baddie_trap_down_gen()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj49;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_trap_left_gen: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      if (type == 8 && numb == 0)
        return myevent_draw();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj50;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj50, 50);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_baddie_trap_left_gen(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 50, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[50]->sprite;
      mask_index = enigma::objectdata[50]->mask;
      visible = enigma::objectdata[50]->visible;
      solid = enigma::objectdata[50]->solid;
      persistent = enigma::objectdata[50]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[50]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj50 = enigma::link_obj_instance(this, 50);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_baddie_trap_left_gen()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj50;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_baddie_trap_right_gen: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_alarm_0();
    inline bool myevent_alarm_0_subcheck();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    
    // Stacked event bases and dispatchers
    void myevent_alarm() override;

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 2 && numb == 0)
        return myevent_alarm_0();
      if (type == 8 && numb == 0)
        return myevent_draw();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj51;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj51, 51);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_baddie_trap_right_gen(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 51, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[51]->sprite;
      mask_index = enigma::objectdata[51]->mask;
      visible = enigma::objectdata[51]->visible;
      solid = enigma::objectdata[51]->solid;
      persistent = enigma::objectdata[51]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[51]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj51 = enigma::link_obj_instance(this, 51);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_baddie_trap_right_gen()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj51;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_window: object_locals
  {
    // Local variables
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 8 && numb == 0)
        return myevent_draw();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj56;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj56, 56);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
    }

    OBJ_obj_window(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 56, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[56]->sprite;
      mask_index = enigma::objectdata[56]->mask;
      visible = enigma::objectdata[56]->visible;
      solid = enigma::objectdata[56]->solid;
      persistent = enigma::objectdata[56]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[56]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj56 = enigma::link_obj_instance(this, 56);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
    }
    
    ~OBJ_obj_window()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj56;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_game_win: object_locals
  {
    // Local variables
    var GameWinBG;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_gameend();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    evariant myevent_keypressed_Escape();
    evariant myevent_keypressed_Space();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 7 && numb == 3)
        return myevent_gameend();
      if (type == 8 && numb == 0)
        return myevent_draw();
      if (type == 9 && numb == 27)
        return myevent_keypressed_Escape();
      if (type == 9 && numb == 32)
        return myevent_keypressed_Space();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj85;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_Escape;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_Space;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_gameend;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj85, 85);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_keypressed_Escape->unlink(ENOBJ_ITER_myevent_keypressed_Escape);
      enigma::event_keypressed_Space->unlink(ENOBJ_ITER_myevent_keypressed_Space);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_gameend->unlink(ENOBJ_ITER_myevent_gameend);
    }

    OBJ_obj_game_win(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 85, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[85]->sprite;
      mask_index = enigma::objectdata[85]->mask;
      visible = enigma::objectdata[85]->visible;
      solid = enigma::objectdata[85]->solid;
      persistent = enigma::objectdata[85]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[85]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj85 = enigma::link_obj_instance(this, 85);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_Escape = enigma::event_keypressed_Escape->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_Space = enigma::event_keypressed_Space->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_gameend = enigma::event_gameend->add_inst(this);
    }
    
    ~OBJ_obj_game_win()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj85;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_keypressed_Escape;
      delete ENOBJ_ITER_myevent_keypressed_Space;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_gameend;
    }
    virtual bool can_cast(int obj) const;
  };
  
  struct OBJ_obj_game_lose: object_locals
  {
    // Local variables
    var GameLoseBG;
    
    //Scripts called by this object
    
    
    //Timelines called by this object

    evariant myevent_create();
    evariant myevent_gameend();
    evariant myevent_draw();
    inline bool myevent_draw_subcheck();
    evariant myevent_keypressed_Escape();
    evariant myevent_keypressed_Space();
    
    // Stacked event bases and dispatchers

    // Event Perform Code
    evariant myevents_perf(int type, int numb) override {
      if (type == 0 && numb == 0)
        return myevent_create();
      if (type == 7 && numb == 3)
        return myevent_gameend();
      if (type == 8 && numb == 0)
        return myevent_draw();
      if (type == 9 && numb == 27)
        return myevent_keypressed_Escape();
      if (type == 9 && numb == 32)
        return myevent_keypressed_Space();
      return 0;
    }

    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj86;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_Escape;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypressed_Space;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_localsweep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_gameend;

    void unlink() {
      instance_iter_queue_for_destroy(this); // Queue for delete while we're still valid
      if (enigma::instance_deactivated_list.erase(id)==0) {
        // If it's not in the deactivated list, then it's active (so deactivate it).
        deactivate();
      }
    }

    void deactivate() {
      enigma::unlink_main(ENOBJ_ITER_me);
      unlink_object_id_iter(ENOBJ_ITER_myobj86, 86);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_keypressed_Escape->unlink(ENOBJ_ITER_myevent_keypressed_Escape);
      enigma::event_keypressed_Space->unlink(ENOBJ_ITER_myevent_keypressed_Space);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_localsweep->unlink(ENOBJ_ITER_myevent_localsweep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_gameend->unlink(ENOBJ_ITER_myevent_gameend);
    }

    OBJ_obj_game_lose(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++), const int enigma_genericobjid = 86, bool handle = true): object_locals(id,enigma_genericobjid) 
    {
      if (!handle) return;
      sprite_index = enigma::objectdata[86]->sprite;
      mask_index = enigma::objectdata[86]->mask;
      visible = enigma::objectdata[86]->visible;
      solid = enigma::objectdata[86]->solid;
      persistent = enigma::objectdata[86]->persistent;
      activate();
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
    }

    void activate()
    {
      depth.init(enigma::objectdata[86]->depth, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj86 = enigma::link_obj_instance(this, 86);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_Escape = enigma::event_keypressed_Escape->add_inst(this);
      ENOBJ_ITER_myevent_keypressed_Space = enigma::event_keypressed_Space->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_localsweep = enigma::event_localsweep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_gameend = enigma::event_gameend->add_inst(this);
    }
    
    ~OBJ_obj_game_lose()
    {
      delete vmap;
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj86;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_keypressed_Escape;
      delete ENOBJ_ITER_myevent_keypressed_Space;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_localsweep;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_gameend;
    }
    virtual bool can_cast(int obj) const;
  };
}

namespace enigma {
  std::vector<objectstruct> objs = {
    { spr_splash_screen, 0, 1, 0.000000, 0, -1, -1, 0 },
    { spr_title_logo, 0, 1, -25.000000, 0, -1, -1, 1 },
    { spr_copyright, 0, 1, -10.000000, 0, -1, -1, 2 },
    { spr_love, 0, 1, -10.000000, 0, -1, -1, 3 },
    { spr_door_top, 0, 1, 0.000000, 0, -1, -1, 4 },
    { spr_door_bottom, 0, 1, 0.000000, 0, -1, -1, 5 },
    { spr_doorknob, 0, 1, 0.000000, 0, -1, -1, 6 },
    { spr_doorway_ver, 0, 1, 0.000000, 0, -1, -1, 7 },
    { spr_doorway_hor, 0, 1, 0.000000, 0, -1, -1, 8 },
    { spr_doorway_corner_left, 0, 1, 0.000000, 0, -1, -1, 9 },
    { spr_doorway_corner_right, 0, 1, 0.000000, 0, -1, -1, 10 },
    { spr_doorway_bottom, 0, 1, 0.000000, 0, -1, -1, 11 },
    { spr_background_shark, 0, 1, 1000.000000, 0, -1, obj_baddie_parent, 12 },
    { -1, 0, 1, -1316134911.000000, 1, -1, -1, 13 },
    { -1, 0, 1, 99999.000000, 1, -1, -1, 14 },
    { spr_char_walk, 0, 1, -1.000000, 0, -1, -1, 15 },
    { spr_char_walk, 0, 1, 0.000000, 0, spr_char_small, -1, 16 },
    { -1, 0, 1, 0.000000, 0, -1, -1, 17 },
    { -1, 0, 1, 0.000000, 0, -1, -1, 18 },
    { -1, 0, 1, 0.000000, 0, -1, -1, 19 },
    { -1, 0, 1, 0.000000, 0, -1, -1, 20 },
    { -1, 1, 1, 0.000000, 0, -1, -1, 21 },
    { -1, 0, 1, 0.000000, 0, -1, -1, 22 },
    { spr_key, 0, 1, -50.000000, 0, -1, -1, 23 },
    { spr_door, 0, 1, 2.000000, 0, -1, -1, 24 },
    { spr_sparkle, 0, 1, -75.000000, 0, -1, -1, 25 },
    { spr_sparkle, 0, 1, -75.000000, 0, -1, -1, 26 },
    { spr_ladder, 0, 1, 1.000000, 0, -1, -1, 27 },
    { spr_water_outline, 0, 1, 50.000000, 0, -1, -1, 28 },
    { spr_water_top, 0, 1, 50.000000, 0, -1, -1, 29 },
    { spr_water_base, 0, 1, 50.000000, 0, -1, obj_water_parent, 30 },
    { spr_paused, 0, 1, -999.000000, 0, -1, -1, 31 },
    { spr_brick, 1, 1, -5.000000, 0, -1, obj_land_parent, 32 },
    { spr_brick_hor, 1, 1, -6.000000, 0, -1, obj_land_parent, 33 },
    { spr_brick_ver, 1, 1, -6.000000, 0, -1, obj_land_parent, 34 },
    { spr_brick_mid, 1, 1, -7.000000, 0, -1, obj_land_parent, 35 },
    { spr_brick, 1, 1, -5.000000, 0, -1, obj_land_parent, 36 },
    { spr_baddie_acid_leak, 0, 1, -8.000000, 0, -1, obj_baddie_parent, 37 },
    { spr_baddie_acid_drop, 0, 1, -3.000000, 0, -1, obj_baddie_parent, 38 },
    { spr_baddie_acid_man, 0, 1, 0.000000, 0, -1, obj_baddie_parent, 39 },
    { spr_baddie_spikes_up, 0, 1, -4.000000, 0, -1, obj_baddie_parent, 40 },
    { spr_baddie_spikes_down, 0, 1, -4.000000, 0, -1, obj_baddie_parent, 41 },
    { spr_baddie_barrier, 0, 0, -999.000000, 0, -1, -1, 42 },
    { spr_wood, 1, 1, -5.000000, 0, -1, obj_land_parent, 43 },
    { spr_wood_hor, 1, 1, -6.000000, 0, -1, obj_land_parent, 44 },
    { spr_wood_ver, 1, 1, -6.000000, 0, -1, obj_land_parent, 45 },
    { spr_wood_mid, 1, 1, -7.000000, 0, -1, obj_land_parent, 46 },
    { spr_wood, 1, 1, -5.000000, 0, -1, obj_land_parent, 47 },
    { spr_baddie_trap_up_gen, 1, 1, -7.000000, 0, -1, -1, 48 },
    { spr_baddie_trap_down_gen, 1, 1, -7.000000, 0, -1, -1, 49 },
    { spr_baddie_trap_left_gen, 1, 1, -7.000000, 0, -1, -1, 50 },
    { spr_baddie_trap_right_gen, 1, 1, -7.000000, 0, -1, -1, 51 },
    { spr_baddie_trap_up, 0, 1, -1.000000, 0, -1, obj_baddie_parent, 52 },
    { spr_baddie_trap_down, 0, 1, -1.000000, 0, -1, obj_baddie_parent, 53 },
    { spr_baddie_trap_left, 0, 1, -1.000000, 0, -1, obj_baddie_parent, 54 },
    { spr_baddie_trap_right, 0, 1, -1.000000, 0, -1, obj_baddie_parent, 55 },
    { spr_window, 0, 1, 2.000000, 0, -1, -1, 56 },
    { spr_coral, 1, 1, -5.000000, 0, -1, obj_land_parent, 57 },
    { spr_coral_hor, 1, 1, -6.000000, 0, -1, obj_land_parent, 58 },
    { spr_coral_ver, 1, 1, -6.000000, 0, -1, obj_land_parent, 59 },
    { spr_coral_mid, 1, 1, -7.000000, 0, -1, obj_land_parent, 60 },
    { spr_baddie_shark, 0, 1, 0.000000, 0, -1, obj_baddie_parent, 61 },
    { spr_rock, 1, 1, -5.000000, 0, -1, obj_land_parent, 62 },
    { spr_rock_hor, 1, 1, -6.000000, 0, -1, obj_land_parent, 63 },
    { spr_rock_ver, 1, 1, -6.000000, 0, -1, obj_land_parent, 64 },
    { spr_rock_mid, 1, 1, -7.000000, 0, -1, obj_land_parent, 65 },
    { spr_rock_hor_large, 1, 1, -6.000000, 0, -1, obj_land_parent, 66 },
    { spr_rock_ver_large, 1, 1, -6.000000, 0, -1, obj_land_parent, 67 },
    { spr_rock_mid_large, 1, 1, -7.000000, 0, -1, obj_land_parent, 68 },
    { spr_rock_mid_large_hor, 1, 1, -7.000000, 0, -1, obj_land_parent, 69 },
    { spr_rock_mid_large_ver, 1, 1, -7.000000, 0, -1, obj_land_parent, 70 },
    { spr_baddie_buzz_saw, 0, 1, -1.000000, 0, -1, obj_baddie_parent, 71 },
    { spr_baddie_buzz_saw, 0, 1, -1.000000, 0, -1, obj_baddie_parent, 72 },
    { spr_baddie_buzz_saw, 0, 1, -1.000000, 0, -1, obj_baddie_parent, 73 },
    { spr_baddie_buzz_saw, 0, 1, -1.000000, 0, -1, obj_baddie_parent, 74 },
    { spr_baddie_buzz_saw, 0, 1, -1.000000, 0, -1, obj_baddie_parent, 75 },
    { spr_baddie_buzz_saw, 0, 1, -1.000000, 0, -1, obj_baddie_parent, 76 },
    { spr_baddie_spike_ball_small_left, 0, 1, -10.000000, 0, -1, obj_baddie_parent, 77 },
    { spr_baddie_spike_ball_small_right, 0, 1, -10.000000, 0, -1, obj_baddie_parent, 78 },
    { spr_baddie_spike_ball_large_left, 0, 1, -10.000000, 0, -1, obj_baddie_parent, 79 },
    { spr_baddie_spike_ball_large_right, 0, 1, -10.000000, 0, -1, obj_baddie_parent, 80 },
    { spr_baddie_fire, 0, 1, -4.000000, 0, -1, obj_baddie_parent, 81 },
    { spr_baddie_lava, 0, 1, -4.000000, 0, -1, obj_baddie_parent, 82 },
    { spr_baddie_fire_ball, 0, 1, 0.000000, 0, -1, obj_baddie_parent, 83 },
    { spr_baddie_fire_ball, 0, 1, 0.000000, 0, -1, obj_baddie_parent, 84 },
    { spr_game_win, 0, 1, -999.000000, 0, -1, -1, 85 },
    { spr_game_lose, 0, 1, -999.000000, 0, -1, -1, 86 },
  };
  int objectcount = 87;
}
