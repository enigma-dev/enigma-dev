// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TIMELINE_H_
#define FLATBUFFERS_GENERATED_TIMELINE_H_

#include "flatbuffers/flatbuffers.h"

struct Moment;

struct Timeline;

struct Moment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STEP = 4,
    VT_CODE = 6
  };
  int32_t step() const {
    return GetField<int32_t>(VT_STEP, 0);
  }
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STEP) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.Verify(code()) &&
           verifier.EndTable();
  }
};

struct MomentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_step(int32_t step) {
    fbb_.AddElement<int32_t>(Moment::VT_STEP, step, 0);
  }
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(Moment::VT_CODE, code);
  }
  explicit MomentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MomentBuilder &operator=(const MomentBuilder &);
  flatbuffers::Offset<Moment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Moment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Moment> CreateMoment(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t step = 0,
    flatbuffers::Offset<flatbuffers::String> code = 0) {
  MomentBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_step(step);
  return builder_.Finish();
}

inline flatbuffers::Offset<Moment> CreateMomentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t step = 0,
    const char *code = nullptr) {
  return CreateMoment(
      _fbb,
      step,
      code ? _fbb.CreateString(code) : 0);
}

struct Timeline FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_ID = 6,
    VT_MOMENTS = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Moment>> *moments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Moment>> *>(VT_MOMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_MOMENTS) &&
           verifier.Verify(moments()) &&
           verifier.VerifyVectorOfTables(moments()) &&
           verifier.EndTable();
  }
};

struct TimelineBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Timeline::VT_NAME, name);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Timeline::VT_ID, id, 0);
  }
  void add_moments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Moment>>> moments) {
    fbb_.AddOffset(Timeline::VT_MOMENTS, moments);
  }
  explicit TimelineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimelineBuilder &operator=(const TimelineBuilder &);
  flatbuffers::Offset<Timeline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Timeline>(end);
    return o;
  }
};

inline flatbuffers::Offset<Timeline> CreateTimeline(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Moment>>> moments = 0) {
  TimelineBuilder builder_(_fbb);
  builder_.add_moments(moments);
  builder_.add_id(id);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Timeline> CreateTimelineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t id = 0,
    const std::vector<flatbuffers::Offset<Moment>> *moments = nullptr) {
  return CreateTimeline(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      id,
      moments ? _fbb.CreateVector<flatbuffers::Offset<Moment>>(*moments) : 0);
}

inline flatbuffers::TypeTable *MomentTypeTable();

inline flatbuffers::TypeTable *TimelineTypeTable();

inline flatbuffers::TypeTable *MomentTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char* attr_keys_0[] = { "gmx" };
  static const char* attr_vals_0[] = { "step" };
  static const flatbuffers::AttributeList attrs[] = {
    { 1, attr_keys_0, attr_vals_0 },
    {}
  };
  static const char *names[] = {
    "step",
    "code"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names, field_attrs
  };
  return &tt;
}

inline flatbuffers::TypeTable *TimelineTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    MomentTypeTable
  };
  static const char* attr_keys_2[] = { "gmx" };
  static const char* attr_vals_2[] = { "entry" };
  static const flatbuffers::AttributeList attrs[] = {
    {},
    {},
    { 1, attr_keys_2, attr_vals_2 }
  };
  static const char *names[] = {
    "name",
    "id",
    "moments"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names, field_attrs
  };
  return &tt;
}

inline const Timeline *GetTimeline(const void *buf) {
  return flatbuffers::GetRoot<Timeline>(buf);
}

inline bool VerifyTimelineBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Timeline>(nullptr);
}

inline void FinishTimelineBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Timeline> root) {
  fbb.Finish(root);
}

#endif  // FLATBUFFERS_GENERATED_TIMELINE_H_
