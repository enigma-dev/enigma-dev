// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SPRITE_H_
#define FLATBUFFERS_GENERATED_SPRITE_H_

#include "flatbuffers/flatbuffers.h"

#include "Image_generated.h"
#include "Point_generated.h"

struct SpriteBoundingBox;

struct Polygon;

struct Sprite;

enum SpriteShape {
  SpriteShape_PRECISE = 0,
  SpriteShape_RECTANGLE = 1,
  SpriteShape_DISK = 2,
  SpriteShape_DIAMOND = 3,
  SpriteShape_MIN = SpriteShape_PRECISE,
  SpriteShape_MAX = SpriteShape_DIAMOND
};

inline SpriteShape (&EnumValuesSpriteShape())[4] {
  static SpriteShape values[] = {
    SpriteShape_PRECISE,
    SpriteShape_RECTANGLE,
    SpriteShape_DISK,
    SpriteShape_DIAMOND
  };
  return values;
}

inline const char **EnumNamesSpriteShape() {
  static const char *names[] = {
    "PRECISE",
    "RECTANGLE",
    "DISK",
    "DIAMOND",
    nullptr
  };
  return names;
}

inline const char *EnumNameSpriteShape(SpriteShape e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSpriteShape()[index];
}

enum SpriteBoundingBoxType {
  SpriteBoundingBoxType_AUTOMATIC = 0,
  SpriteBoundingBoxType_FULL_IMAGE = 1,
  SpriteBoundingBoxType_MANUAL = 2,
  SpriteBoundingBoxType_MIN = SpriteBoundingBoxType_AUTOMATIC,
  SpriteBoundingBoxType_MAX = SpriteBoundingBoxType_MANUAL
};

inline SpriteBoundingBoxType (&EnumValuesSpriteBoundingBoxType())[3] {
  static SpriteBoundingBoxType values[] = {
    SpriteBoundingBoxType_AUTOMATIC,
    SpriteBoundingBoxType_FULL_IMAGE,
    SpriteBoundingBoxType_MANUAL
  };
  return values;
}

inline const char **EnumNamesSpriteBoundingBoxType() {
  static const char *names[] = {
    "AUTOMATIC",
    "FULL_IMAGE",
    "MANUAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameSpriteBoundingBoxType(SpriteBoundingBoxType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSpriteBoundingBoxType()[index];
}

MANUALLY_ALIGNED_STRUCT(4) SpriteBoundingBox FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t type_;
  int8_t padding0__;  int16_t padding1__;
  int32_t left_;
  int32_t right_;
  int32_t top_;
  int32_t bottom_;

 public:
  SpriteBoundingBox() {
    memset(this, 0, sizeof(SpriteBoundingBox));
  }
  SpriteBoundingBox(SpriteBoundingBoxType _type, int32_t _left, int32_t _right, int32_t _top, int32_t _bottom)
      : type_(flatbuffers::EndianScalar(static_cast<int8_t>(_type))),
        padding0__(0),
        padding1__(0),
        left_(flatbuffers::EndianScalar(_left)),
        right_(flatbuffers::EndianScalar(_right)),
        top_(flatbuffers::EndianScalar(_top)),
        bottom_(flatbuffers::EndianScalar(_bottom)) {
    (void)padding0__;    (void)padding1__;
  }
  SpriteBoundingBoxType type() const {
    return static_cast<SpriteBoundingBoxType>(flatbuffers::EndianScalar(type_));
  }
  int32_t left() const {
    return flatbuffers::EndianScalar(left_);
  }
  int32_t right() const {
    return flatbuffers::EndianScalar(right_);
  }
  int32_t top() const {
    return flatbuffers::EndianScalar(top_);
  }
  int32_t bottom() const {
    return flatbuffers::EndianScalar(bottom_);
  }
};
STRUCT_END(SpriteBoundingBox, 20);

struct Polygon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POINTS = 4
  };
  const flatbuffers::Vector<const Point *> *points() const {
    return GetPointer<const flatbuffers::Vector<const Point *> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.Verify(points()) &&
           verifier.EndTable();
  }
};

struct PolygonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const Point *>> points) {
    fbb_.AddOffset(Polygon::VT_POINTS, points);
  }
  explicit PolygonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PolygonBuilder &operator=(const PolygonBuilder &);
  flatbuffers::Offset<Polygon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Polygon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Polygon> CreatePolygon(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const Point *>> points = 0) {
  PolygonBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

inline flatbuffers::Offset<Polygon> CreatePolygonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<const Point *> *points = nullptr) {
  return CreatePolygon(
      _fbb,
      points ? _fbb.CreateVector<const Point *>(*points) : 0);
}

struct Sprite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_ID = 6,
    VT_PRELOAD = 8,
    VT_TRANSPARENT = 10,
    VT_SMOOTH_EDGES = 12,
    VT_SHAPE = 14,
    VT_ALPHA_TOLERANCE = 16,
    VT_SEPARATE_MASK = 18,
    VT_ORIGIN_X = 20,
    VT_ORIGIN_Y = 22,
    VT_BOUNDING_BOX = 24,
    VT_SUBIMAGES = 26,
    VT_MASK_SHAPES = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool preload() const {
    return GetField<uint8_t>(VT_PRELOAD, 0) != 0;
  }
  bool transparent() const {
    return GetField<uint8_t>(VT_TRANSPARENT, 0) != 0;
  }
  bool smooth_edges() const {
    return GetField<uint8_t>(VT_SMOOTH_EDGES, 0) != 0;
  }
  SpriteShape shape() const {
    return static_cast<SpriteShape>(GetField<int8_t>(VT_SHAPE, 0));
  }
  int32_t alpha_tolerance() const {
    return GetField<int32_t>(VT_ALPHA_TOLERANCE, 0);
  }
  bool separate_mask() const {
    return GetField<uint8_t>(VT_SEPARATE_MASK, 0) != 0;
  }
  int32_t origin_x() const {
    return GetField<int32_t>(VT_ORIGIN_X, 0);
  }
  int32_t origin_y() const {
    return GetField<int32_t>(VT_ORIGIN_Y, 0);
  }
  const SpriteBoundingBox *bounding_box() const {
    return GetStruct<const SpriteBoundingBox *>(VT_BOUNDING_BOX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Image>> *subimages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Image>> *>(VT_SUBIMAGES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Polygon>> *mask_shapes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Polygon>> *>(VT_MASK_SHAPES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_PRELOAD) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPARENT) &&
           VerifyField<uint8_t>(verifier, VT_SMOOTH_EDGES) &&
           VerifyField<int8_t>(verifier, VT_SHAPE) &&
           VerifyField<int32_t>(verifier, VT_ALPHA_TOLERANCE) &&
           VerifyField<uint8_t>(verifier, VT_SEPARATE_MASK) &&
           VerifyField<int32_t>(verifier, VT_ORIGIN_X) &&
           VerifyField<int32_t>(verifier, VT_ORIGIN_Y) &&
           VerifyField<SpriteBoundingBox>(verifier, VT_BOUNDING_BOX) &&
           VerifyOffset(verifier, VT_SUBIMAGES) &&
           verifier.Verify(subimages()) &&
           verifier.VerifyVectorOfTables(subimages()) &&
           VerifyOffset(verifier, VT_MASK_SHAPES) &&
           verifier.Verify(mask_shapes()) &&
           verifier.VerifyVectorOfTables(mask_shapes()) &&
           verifier.EndTable();
  }
};

struct SpriteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Sprite::VT_NAME, name);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Sprite::VT_ID, id, 0);
  }
  void add_preload(bool preload) {
    fbb_.AddElement<uint8_t>(Sprite::VT_PRELOAD, static_cast<uint8_t>(preload), 0);
  }
  void add_transparent(bool transparent) {
    fbb_.AddElement<uint8_t>(Sprite::VT_TRANSPARENT, static_cast<uint8_t>(transparent), 0);
  }
  void add_smooth_edges(bool smooth_edges) {
    fbb_.AddElement<uint8_t>(Sprite::VT_SMOOTH_EDGES, static_cast<uint8_t>(smooth_edges), 0);
  }
  void add_shape(SpriteShape shape) {
    fbb_.AddElement<int8_t>(Sprite::VT_SHAPE, static_cast<int8_t>(shape), 0);
  }
  void add_alpha_tolerance(int32_t alpha_tolerance) {
    fbb_.AddElement<int32_t>(Sprite::VT_ALPHA_TOLERANCE, alpha_tolerance, 0);
  }
  void add_separate_mask(bool separate_mask) {
    fbb_.AddElement<uint8_t>(Sprite::VT_SEPARATE_MASK, static_cast<uint8_t>(separate_mask), 0);
  }
  void add_origin_x(int32_t origin_x) {
    fbb_.AddElement<int32_t>(Sprite::VT_ORIGIN_X, origin_x, 0);
  }
  void add_origin_y(int32_t origin_y) {
    fbb_.AddElement<int32_t>(Sprite::VT_ORIGIN_Y, origin_y, 0);
  }
  void add_bounding_box(const SpriteBoundingBox *bounding_box) {
    fbb_.AddStruct(Sprite::VT_BOUNDING_BOX, bounding_box);
  }
  void add_subimages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Image>>> subimages) {
    fbb_.AddOffset(Sprite::VT_SUBIMAGES, subimages);
  }
  void add_mask_shapes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Polygon>>> mask_shapes) {
    fbb_.AddOffset(Sprite::VT_MASK_SHAPES, mask_shapes);
  }
  explicit SpriteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpriteBuilder &operator=(const SpriteBuilder &);
  flatbuffers::Offset<Sprite> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sprite>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sprite> CreateSprite(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t id = 0,
    bool preload = false,
    bool transparent = false,
    bool smooth_edges = false,
    SpriteShape shape = SpriteShape_PRECISE,
    int32_t alpha_tolerance = 0,
    bool separate_mask = false,
    int32_t origin_x = 0,
    int32_t origin_y = 0,
    const SpriteBoundingBox *bounding_box = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Image>>> subimages = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Polygon>>> mask_shapes = 0) {
  SpriteBuilder builder_(_fbb);
  builder_.add_mask_shapes(mask_shapes);
  builder_.add_subimages(subimages);
  builder_.add_bounding_box(bounding_box);
  builder_.add_origin_y(origin_y);
  builder_.add_origin_x(origin_x);
  builder_.add_alpha_tolerance(alpha_tolerance);
  builder_.add_id(id);
  builder_.add_name(name);
  builder_.add_separate_mask(separate_mask);
  builder_.add_shape(shape);
  builder_.add_smooth_edges(smooth_edges);
  builder_.add_transparent(transparent);
  builder_.add_preload(preload);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sprite> CreateSpriteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t id = 0,
    bool preload = false,
    bool transparent = false,
    bool smooth_edges = false,
    SpriteShape shape = SpriteShape_PRECISE,
    int32_t alpha_tolerance = 0,
    bool separate_mask = false,
    int32_t origin_x = 0,
    int32_t origin_y = 0,
    const SpriteBoundingBox *bounding_box = 0,
    const std::vector<flatbuffers::Offset<Image>> *subimages = nullptr,
    const std::vector<flatbuffers::Offset<Polygon>> *mask_shapes = nullptr) {
  return CreateSprite(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      id,
      preload,
      transparent,
      smooth_edges,
      shape,
      alpha_tolerance,
      separate_mask,
      origin_x,
      origin_y,
      bounding_box,
      subimages ? _fbb.CreateVector<flatbuffers::Offset<Image>>(*subimages) : 0,
      mask_shapes ? _fbb.CreateVector<flatbuffers::Offset<Polygon>>(*mask_shapes) : 0);
}

inline flatbuffers::TypeTable *SpriteBoundingBoxTypeTable();

inline flatbuffers::TypeTable *PolygonTypeTable();

inline flatbuffers::TypeTable *SpriteTypeTable();

inline flatbuffers::TypeTable *SpriteShapeTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    SpriteShapeTypeTable
  };
  static const int32_t values[] = { 0, 1, 2, 3 };
  static const char *names[] = {
    "PRECISE",
    "RECTANGLE",
    "DISK",
    "DIAMOND"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, values, names, nullptr
  };
  return &tt;
}

inline flatbuffers::TypeTable *SpriteBoundingBoxTypeTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    SpriteBoundingBoxTypeTypeTable
  };
  static const int32_t values[] = { 0, 1, 2 };
  static const char *names[] = {
    "AUTOMATIC",
    "FULL_IMAGE",
    "MANUAL"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, values, names, nullptr
  };
  return &tt;
}

inline flatbuffers::TypeTable *SpriteBoundingBoxTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    SpriteBoundingBoxTypeTypeTable
  };
  static const int32_t values[] = { 0, 4, 8, 12, 16, 20 };
  static const char* attr_keys_0[] = { "gmx" };
  static const char* attr_vals_0[] = { "bboxmode" };
  static const char* attr_keys_1[] = { "gmx" };
  static const char* attr_vals_1[] = { "bbox_left" };
  static const char* attr_keys_2[] = { "gmx" };
  static const char* attr_vals_2[] = { "bbox_right" };
  static const char* attr_keys_3[] = { "gmx" };
  static const char* attr_vals_3[] = { "bbox_top" };
  static const char* attr_keys_4[] = { "gmx" };
  static const char* attr_vals_4[] = { "bbox_bottom" };
  static const flatbuffers::AttributeList attrs[] = {
    { 1, attr_keys_0, attr_vals_0 },
    { 1, attr_keys_1, attr_vals_1 },
    { 1, attr_keys_2, attr_vals_2 },
    { 1, attr_keys_3, attr_vals_3 },
    { 1, attr_keys_4, attr_vals_4 }
  };
  static const char *names[] = {
    "type",
    "left",
    "right",
    "top",
    "bottom"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 5, type_codes, type_refs, values, names, field_attrs
  };
  return &tt;
}

inline flatbuffers::TypeTable *PolygonTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    PointTypeTable
  };
  static const char *names[] = {
    "points"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names, nullptr
  };
  return &tt;
}

inline flatbuffers::TypeTable *SpriteTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    SpriteShapeTypeTable,
    SpriteBoundingBoxTypeTable,
    ImageTypeTable,
    PolygonTypeTable
  };
  static const char* attr_keys_5[] = { "gmx" };
  static const char* attr_vals_5[] = { "type" };
  static const char* attr_keys_6[] = { "gmx" };
  static const char* attr_vals_6[] = { "coltolerance" };
  static const char* attr_keys_7[] = { "gmx" };
  static const char* attr_vals_7[] = { "sepmasks" };
  static const char* attr_keys_8[] = { "gmx" };
  static const char* attr_vals_8[] = { "xorig" };
  static const char* attr_keys_9[] = { "gmx" };
  static const char* attr_vals_9[] = { "yorigin" };
  static const char* attr_keys_11[] = { "gmx" };
  static const char* attr_vals_11[] = { "frames" };
  static const flatbuffers::AttributeList attrs[] = {
    {},
    {},
    {},
    {},
    {},
    { 1, attr_keys_5, attr_vals_5 },
    { 1, attr_keys_6, attr_vals_6 },
    { 1, attr_keys_7, attr_vals_7 },
    { 1, attr_keys_8, attr_vals_8 },
    { 1, attr_keys_9, attr_vals_9 },
    {},
    { 1, attr_keys_11, attr_vals_11 },
    {}
  };
  static const char *names[] = {
    "name",
    "id",
    "preload",
    "transparent",
    "smooth_edges",
    "shape",
    "alpha_tolerance",
    "separate_mask",
    "origin_x",
    "origin_y",
    "bounding_box",
    "subimages",
    "mask_shapes"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 13, type_codes, type_refs, nullptr, names, field_attrs
  };
  return &tt;
}

inline const Sprite *GetSprite(const void *buf) {
  return flatbuffers::GetRoot<Sprite>(buf);
}

inline bool VerifySpriteBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Sprite>(nullptr);
}

inline void FinishSpriteBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Sprite> root) {
  fbb.Finish(root);
}

#endif  // FLATBUFFERS_GENERATED_SPRITE_H_
