// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FONT_H_
#define FLATBUFFERS_GENERATED_FONT_H_

#include "flatbuffers/flatbuffers.h"

struct Glyph;

struct GlyphRange;

struct Font;

struct Glyph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ORIGIN = 4,
    VT_BASELINE = 6,
    VT_ADVANCE = 8,
    VT_WIDTH = 10,
    VT_HEIGHT = 12,
    VT_DATA = 14
  };
  double origin() const {
    return GetField<double>(VT_ORIGIN, 0.0);
  }
  double baseline() const {
    return GetField<double>(VT_BASELINE, 0.0);
  }
  double advance() const {
    return GetField<double>(VT_ADVANCE, 0.0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_ORIGIN) &&
           VerifyField<double>(verifier, VT_BASELINE) &&
           VerifyField<double>(verifier, VT_ADVANCE) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct GlyphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_origin(double origin) {
    fbb_.AddElement<double>(Glyph::VT_ORIGIN, origin, 0.0);
  }
  void add_baseline(double baseline) {
    fbb_.AddElement<double>(Glyph::VT_BASELINE, baseline, 0.0);
  }
  void add_advance(double advance) {
    fbb_.AddElement<double>(Glyph::VT_ADVANCE, advance, 0.0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(Glyph::VT_WIDTH, width, 0);
  }
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(Glyph::VT_HEIGHT, height, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(Glyph::VT_DATA, data);
  }
  explicit GlyphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GlyphBuilder &operator=(const GlyphBuilder &);
  flatbuffers::Offset<Glyph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Glyph>(end);
    return o;
  }
};

inline flatbuffers::Offset<Glyph> CreateGlyph(
    flatbuffers::FlatBufferBuilder &_fbb,
    double origin = 0.0,
    double baseline = 0.0,
    double advance = 0.0,
    int32_t width = 0,
    int32_t height = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0) {
  GlyphBuilder builder_(_fbb);
  builder_.add_advance(advance);
  builder_.add_baseline(baseline);
  builder_.add_origin(origin);
  builder_.add_data(data);
  builder_.add_height(height);
  builder_.add_width(width);
  return builder_.Finish();
}

inline flatbuffers::Offset<Glyph> CreateGlyphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double origin = 0.0,
    double baseline = 0.0,
    double advance = 0.0,
    int32_t width = 0,
    int32_t height = 0,
    const std::vector<int8_t> *data = nullptr) {
  return CreateGlyph(
      _fbb,
      origin,
      baseline,
      advance,
      width,
      height,
      data ? _fbb.CreateVector<int8_t>(*data) : 0);
}

struct GlyphRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_GLYPHS = 8
  };
  int32_t min() const {
    return GetField<int32_t>(VT_MIN, 0);
  }
  int32_t max() const {
    return GetField<int32_t>(VT_MAX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Glyph>> *glyphs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Glyph>> *>(VT_GLYPHS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MIN) &&
           VerifyField<int32_t>(verifier, VT_MAX) &&
           VerifyOffset(verifier, VT_GLYPHS) &&
           verifier.Verify(glyphs()) &&
           verifier.VerifyVectorOfTables(glyphs()) &&
           verifier.EndTable();
  }
};

struct GlyphRangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(int32_t min) {
    fbb_.AddElement<int32_t>(GlyphRange::VT_MIN, min, 0);
  }
  void add_max(int32_t max) {
    fbb_.AddElement<int32_t>(GlyphRange::VT_MAX, max, 0);
  }
  void add_glyphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Glyph>>> glyphs) {
    fbb_.AddOffset(GlyphRange::VT_GLYPHS, glyphs);
  }
  explicit GlyphRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GlyphRangeBuilder &operator=(const GlyphRangeBuilder &);
  flatbuffers::Offset<GlyphRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GlyphRange>(end);
    return o;
  }
};

inline flatbuffers::Offset<GlyphRange> CreateGlyphRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min = 0,
    int32_t max = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Glyph>>> glyphs = 0) {
  GlyphRangeBuilder builder_(_fbb);
  builder_.add_glyphs(glyphs);
  builder_.add_max(max);
  builder_.add_min(min);
  return builder_.Finish();
}

inline flatbuffers::Offset<GlyphRange> CreateGlyphRangeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min = 0,
    int32_t max = 0,
    const std::vector<flatbuffers::Offset<Glyph>> *glyphs = nullptr) {
  return CreateGlyphRange(
      _fbb,
      min,
      max,
      glyphs ? _fbb.CreateVector<flatbuffers::Offset<Glyph>>(*glyphs) : 0);
}

struct Font FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_ID = 6,
    VT_FONT_NAME = 8,
    VT_SIZE = 10,
    VT_BOLD = 12,
    VT_ITALIC = 14,
    VT_GLYPH_RANGES = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *font_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FONT_NAME);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  bool bold() const {
    return GetField<uint8_t>(VT_BOLD, 0) != 0;
  }
  bool italic() const {
    return GetField<uint8_t>(VT_ITALIC, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<GlyphRange>> *glyph_ranges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GlyphRange>> *>(VT_GLYPH_RANGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_FONT_NAME) &&
           verifier.Verify(font_name()) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_BOLD) &&
           VerifyField<uint8_t>(verifier, VT_ITALIC) &&
           VerifyOffset(verifier, VT_GLYPH_RANGES) &&
           verifier.Verify(glyph_ranges()) &&
           verifier.VerifyVectorOfTables(glyph_ranges()) &&
           verifier.EndTable();
  }
};

struct FontBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Font::VT_NAME, name);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Font::VT_ID, id, 0);
  }
  void add_font_name(flatbuffers::Offset<flatbuffers::String> font_name) {
    fbb_.AddOffset(Font::VT_FONT_NAME, font_name);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(Font::VT_SIZE, size, 0);
  }
  void add_bold(bool bold) {
    fbb_.AddElement<uint8_t>(Font::VT_BOLD, static_cast<uint8_t>(bold), 0);
  }
  void add_italic(bool italic) {
    fbb_.AddElement<uint8_t>(Font::VT_ITALIC, static_cast<uint8_t>(italic), 0);
  }
  void add_glyph_ranges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GlyphRange>>> glyph_ranges) {
    fbb_.AddOffset(Font::VT_GLYPH_RANGES, glyph_ranges);
  }
  explicit FontBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FontBuilder &operator=(const FontBuilder &);
  flatbuffers::Offset<Font> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Font>(end);
    return o;
  }
};

inline flatbuffers::Offset<Font> CreateFont(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> font_name = 0,
    int32_t size = 0,
    bool bold = false,
    bool italic = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GlyphRange>>> glyph_ranges = 0) {
  FontBuilder builder_(_fbb);
  builder_.add_glyph_ranges(glyph_ranges);
  builder_.add_size(size);
  builder_.add_font_name(font_name);
  builder_.add_id(id);
  builder_.add_name(name);
  builder_.add_italic(italic);
  builder_.add_bold(bold);
  return builder_.Finish();
}

inline flatbuffers::Offset<Font> CreateFontDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t id = 0,
    const char *font_name = nullptr,
    int32_t size = 0,
    bool bold = false,
    bool italic = false,
    const std::vector<flatbuffers::Offset<GlyphRange>> *glyph_ranges = nullptr) {
  return CreateFont(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      id,
      font_name ? _fbb.CreateString(font_name) : 0,
      size,
      bold,
      italic,
      glyph_ranges ? _fbb.CreateVector<flatbuffers::Offset<GlyphRange>>(*glyph_ranges) : 0);
}

inline const Font *GetFont(const void *buf) {
  return flatbuffers::GetRoot<Font>(buf);
}

inline bool VerifyFontBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Font>(nullptr);
}

inline void FinishFontBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Font> root) {
  fbb.Finish(root);
}

#endif  // FLATBUFFERS_GENERATED_FONT_H_
